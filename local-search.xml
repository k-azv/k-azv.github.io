<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/02/24/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>表达式与语句的区别主要是两点：</p><ul><li>语句可以包含表达式，但是表达式本身不构成语句。</li><li>表达式都有返回值，语句不一定有。因为语句用来执行某个命令，很多时候不需要返回值，比如变量声明语句（int x &#x3D; 1）就没有返回值。</li></ul><table><thead><tr><th align="center"></th><th align="center">是否可以构成语句</th><th align="center">有无返回值</th></tr></thead><tbody><tr><td align="center">语句</td><td align="center"></td><td align="center">不一定</td></tr><tr><td align="center">表达式</td><td align="center">不可</td><td align="center">一定有</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1.基本语法</title>
    <link href="/2024/02/24/%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/02/24/%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-语句"><a href="#1-语句" class="headerlink" title="1.语句"></a>1.语句</h1><blockquote><p>语句必须使用分号结尾</p><blockquote><p>允许一句多行，一句多行<br>语句间分隔只由<strong>分号</strong><code> ；</code>决定</p></blockquote></blockquote><p>单个分号也是有效语句，称为“空语句”，虽然毫无作用。</p><h1 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2.表达式"></a>2.表达式</h1><blockquote><p>C 语言的各种计算，主要通过表达式完成。表达（expression）是一个计算式，用来获取值。</p></blockquote><p>例<br><code>1 + 2</code></p><blockquote><p>表达式加上分号，也可以成为语句，但是没有实际的作用。</p></blockquote><p>[[表达式与语句的区别|表达式与语句的区别]]</p><h1 id="3-语句块"><a href="#3-语句块" class="headerlink" title="3. 语句块"></a>3. 语句块</h1><blockquote><p>多个语句使用一对大括号 <code>&#123;&#125;</code>，组成一个块，也称为复合语句</p><blockquote><p>语法上，语句块可以视为多个语句组成的一个复合语句<br>语句块的结尾不需要使用 <code>；</code> 分隔</p></blockquote></blockquote><h1 id="4-空格"><a href="#4-空格" class="headerlink" title="4.空格"></a>4.空格</h1><blockquote><p>主要用来帮助编译器区分语法单位。</p><blockquote><p>如果语法单位不用空格就能区分，空格就不是必须的，只是为了增加代码的可读性<br>语法单位之间的<strong>多个空格，等同于单个空格</strong><br>可用缩进体现代码的层级关系，但<strong>有无空格不影响编译</strong><br>大多数 C 语言的风格要求是，<strong>下一级代码比上一级缩进4个空格。</strong>、</p></blockquote></blockquote><h1 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h1><p><code>/*……*/</code> 类似于 python 中的多行注释，&#x3D;&#x3D;但是可以插在行内，并且注释之后的代码仍可有效执行&#x3D;&#x3D;，编译之后<strong>注释将会被替换成空格</strong>，如 <code>min/* space */Value</code> 会变成 <code>min Value</code>，而不是 <code>minValue</code></p><p><code>//</code> 双斜杠类似于 python 中的单行注释</p><p>[[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#注释|python中的注释]]</p><h1 id="6-printf"><a href="#6-printf" class="headerlink" title="6.printf()"></a>6.printf()</h1><h2 id="6-1-基本用法"><a href="#6-1-基本用法" class="headerlink" title="6.1 基本用法"></a>6.1 基本用法</h2><p><code>printf()</code> &#x3D; print in python</p><table><thead><tr><th>与 print() 的区别</th><th></th></tr></thead><tbody><tr><td>换行</td><td><code>printf()</code> 不会自动换行，需要手动添加 [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#2.3.3 添加空白|换行符]] \n (与 python 一致)</td></tr><tr><td>使用</td><td><code>printf()</code> 是由标准库的头文件 <code>stdio.h</code> 定义的函数，使用时需要引入</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-占位符"><a href="#6-2-占位符" class="headerlink" title="6.2 占位符"></a>6.2 占位符</h2><p><code>printf()</code> 可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入，从第二个参数开始按<strong>顺序</strong>表示填入占位符中的值</p><p>占位符的第一个字符必定为 %，第二个字符表示占位符的类型</p><table><thead><tr><th align="center">常用占位符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%a</td><td align="center">十六进制浮点数，字母输出为小写。</td></tr><tr><td align="center">%A</td><td align="center">十六进制浮点数，字母输出为大写。</td></tr><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%d</td><td align="center">十进制整数</td></tr><tr><td align="center">%e</td><td align="center">使用科学计数法的浮点数，指数部分的 e 为小写。</td></tr><tr><td align="center">%E</td><td align="center">使用科学计数法的浮点数，指数部分的 E 为大写。</td></tr><tr><td align="center">%i</td><td align="center">整数，基本等同于%d</td></tr><tr><td align="center">%f</td><td align="center">小数（包含 float 类型和 double 类型）</td></tr><tr><td align="center">%g</td><td align="center">6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的 e 为小写。</td></tr><tr><td align="center">%G</td><td align="center">等同于%g，唯一的区别是指数部分的 E 为大写。</td></tr><tr><td align="center">%hd</td><td align="center">十进制 short int 类型</td></tr><tr><td align="center">%ho</td><td align="center">八进制 short int 类型</td></tr><tr><td align="center">%hx</td><td align="center">十六进制 short int 类型</td></tr><tr><td align="center">%hu</td><td align="center">unsigned short int 类型</td></tr><tr><td align="center">%ld</td><td align="center">十进制 long int 类型</td></tr><tr><td align="center">%lo</td><td align="center">八进制 long int 类型</td></tr><tr><td align="center">%lx</td><td align="center">十六进制 long int 类型</td></tr><tr><td align="center">%lu</td><td align="center">unsigned long int 类型</td></tr><tr><td align="center">%lld</td><td align="center">十进制 long long int 类型</td></tr><tr><td align="center">%llo</td><td align="center">八进制 long long int 类型</td></tr><tr><td align="center">%llx</td><td align="center">十六进制 long long int 类型</td></tr><tr><td align="center">%llu</td><td align="center">unsigned long long int 类型</td></tr><tr><td align="center">%Le</td><td align="center">科学计数法表示的 long double 类型浮点数</td></tr><tr><td align="center">%Lf</td><td align="center">long double 类型浮点数</td></tr><tr><td align="center">%n</td><td align="center">已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。</td></tr><tr><td align="center">%o</td><td align="center">八进制整数</td></tr><tr><td align="center">%p</td><td align="center">指针</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%u</td><td align="center">无符号整数（unsigned int）</td></tr><tr><td align="center">%x</td><td align="center">十六进制整数</td></tr><tr><td align="center">%zd&#x2F;%zu</td><td align="center">size_t 类型</td></tr><tr><td align="center">%%</td><td align="center">输出一个百分号</td></tr></tbody></table><h2 id="6-3-输出格式"><a href="#6-3-输出格式" class="headerlink" title="6.3 输出格式"></a>6.3 输出格式</h2><p><code>printf()</code> 可以定制占位符的输出格式</p><h3 id="限定宽度"><a href="#限定宽度" class="headerlink" title="限定宽度"></a>限定宽度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d\n&quot;</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 输出为 &quot;  123&quot;</span><br></code></pre></td></tr></table></figure><p>在占位符的 %之后可标明占位符的最小宽度，假设提供的值不满该宽度，将会在对应的值前添加空格</p><p>输出的值默认为右对齐，在 <code>%</code> 后添加 <code>-</code> 可修改为左对齐</p><h3 id="总是显示正负号"><a href="#总是显示正负号" class="headerlink" title="总是显示正负号"></a>总是显示正负号</h3><p>默认情况下正数不显示 <code>+</code> 号<br>在占位符 <code>%</code> 后添加 <code>+</code> 可让正数输出 <code>+</code> 号</p><h3 id="限定小数位数"><a href="#限定小数位数" class="headerlink" title="限定小数位数"></a>限定小数位数</h3><p>在 <code>%</code> 的后面添加 <code>.</code> +期望保留的小数位数<br>如 <code>printf(&quot;Number is %.2f\n&quot;, 0.5)</code> 将只保留小数点后两位</p><p>对于是否始终显示正负号和左对齐的修改，<code>+</code> 与 <code>-</code> 的顺序可<strong>随意调换</strong>不影响执行，但是需要<strong>始终排在宽度之后</strong>，同时为避免歧义，在对宽度的指定需要在对小数位数的限定<strong>之前</strong>，如 <code>%6.2</code> 表示宽度为六同时保存到小数点后二位</p><h3 id="输出部分字符串"><a href="#输出部分字符串" class="headerlink" title="输出部分字符串"></a>输出部分字符串</h3><blockquote><p><code>%s</code> 占位符用来输出字符串，默认是全部输出。如果只想输出开头的部分，可以用 <code>%.[m]s</code> 指定输出的长度，其中 <code>[m]</code> 代表一个数字，表示所要输出的长度。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.5s\n&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//将会输出 hello </span><br></code></pre></td></tr></table></figure><h1 id="7-标准库，头文件"><a href="#7-标准库，头文件" class="headerlink" title="7. 标准库，头文件"></a>7. 标准库，头文件</h1><blockquote><p>C 语言自带的所有这些功能，统称为“标准库”（standard library）<br>不同的功能定义在不同的文件里面，这些文件统称为“头文件”（header file）</p><blockquote><p>头文件的后缀通常是 <code>.h</code><br>使用 <code>#include</code> 命令加载头文件<br>类似于 python 中的库或者说 [[..&#x2F;python&#x2F;一、基础知识&#x2F;8. 函数#8.6 在模块中储存函数|模块]] </p></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.函数</title>
    <link href="/2024/02/24/%E4%B8%83%E3%80%81%E5%87%BD%E6%95%B0/"/>
    <url>/2024/02/24/%E4%B8%83%E3%80%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p>函数是一段可以重复执行的代码。它可以接受不同的参数，完成对应的操作。下面的例子就是一个函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">plus_one</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明了一个函数 <code>plus_one</code> </p><p>声明函数的语法</p><ol><li>返回值类型。函数声明时，首先需要给出返回值的类型<br>如上例中 <code>int plus_one</code>，表明返回值为整数</li><li>参数。函数名后面的圆括号里面，需要声明参数的类型和参数名<br><code>int n</code></li><li>函数体。函数体要写在大括号里面，<strong>后面（即大括号外面）不需要加分号</strong>，大括号可与函数名同行也可另起一行</li><li><code>return</code> 语句。<code>return</code> 语句给出函数的返回值，程序<strong>运行到这一行，就会跳出函数体</strong>，结束函数的调用。如果函数没有<strong>返回值，可以省略 <code>return</code> 语句，或者写成 <code>return;</code></strong></li></ol><p>调用函数的方法同 [[..&#x2F;python&#x2F;一、基础知识&#x2F;8. 函数#8.1 定义函数|python]]</p><p>函数只能声明在源码文件的<strong>顶层</strong>，不能声明在其他函数内部</p><p>不返回值的函数，使用 <code>void</code> 关键字表示返回值的类型。没有参数的函数，声明时要用 <code>void</code> 关键字表示参数类型。（总之参数不能空着，也必须要声明一下）</p><p>函数可以<strong>调用自身</strong>，这就叫做递归（recursion）</p><h1 id="2-main"><a href="#2-main" class="headerlink" title="2. main()"></a>2. main()</h1><blockquote><p>C 语言规定，<code>main()</code> 是程序的入口函数，即所有的程序<strong>一定要包含一个 <code>main()</code> 函数</strong>。程序<strong>总是从这个函数开始执行</strong>，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。<br><code>main()</code> 的写法与其他函数一样，要给出返回值的类型和参数的类型</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，最后的 <code>return 0;</code> 表示函数结束运行，返回 <code>0</code>。<br>返回值 <code>0</code> 表示函数运行成功，如果<strong>返回其他非零整数，就表示运行失败</strong>，代码出了问题。系统根据**<code>main()</code> 的返回值，作为整个程序的返回值**，确定程序是否运行成功。<br>假设省略了 <code>return 0;</code> 编译器会自动加上，即 <code>main()</code> 的默认返回值为0<br>C 语言只会对 <code>main()</code> 函数默认添加返回值</p><h1 id="3-参数的传值引用"><a href="#3-参数的传值引用" class="headerlink" title="3.参数的传值引用"></a>3.参数的传值引用</h1><blockquote><p>如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身。<br>因此，如果参数变量发生变化，最好把它<strong>作为返回值传出来</strong>。</p></blockquote><p>对应[[二、变量#2. 变量的声明|块作用域的特性]]，即代码块内的变量无法在代码块外读取，函数修改的变量只是原始变量的拷贝</p><p>如果想要<strong>传入变量本身</strong>，只有一个办法，就是<strong>传入变量的地址</strong><br>即让代码块内的变量通过指针与外界沟通</p><p>函数不要返回内部变量的指针，<code>return &amp;i；</code>,因为当函数结束运行时，内部变量就消失了，这时指向内部变量 <code>i</code> 的内存地址就是无效的</p><h1 id="4-函数指针"><a href="#4-函数指针" class="headerlink" title="4. 函数指针"></a>4. 函数指针</h1><blockquote><p>函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br>&#125;<br><span class="hljs-comment">/* int *a = &amp;x*/</span><br><span class="hljs-type">void</span> (*print_ptr)(<span class="hljs-type">int</span>) = &amp;print;<br><span class="hljs-comment">/*变量类型  *指针变量的名称 参数*/</span><br></code></pre></td></tr></table></figure><p>上面示例中，变量 <code>print_ptr</code> 是一个函数指针，它指向函数 <code>print()</code> 的地址。函数 <code>print()</code> 的地址可以用 <code>&amp;print</code> 获得。<code>(*print_ptr)</code><strong>一定要写在圆括号</strong>里面，否则函数参数 <code>(int)</code> 的优先级高于 <code>*</code>，整个式子就会变成 <code>void* print_ptr(int)</code>。</p><p>比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，**<code>print</code> 和 <code>&amp;print</code> 是一回事。**<br>并且 <code>*print</code> 与 <code>print</code> 也等价<br>这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compute</span><span class="hljs-params">(<span class="hljs-type">int</span> (*myfunc)(<span class="hljs-type">int</span>), <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></figure><p>上面示例可以清晰地表明，函数 <code>compute()</code> 的第一个参数也是一个函数。</p><h1 id="5-函数原型"><a href="#5-函数原型" class="headerlink" title="5. 函数原型"></a>5. 函数原型</h1><blockquote><p>前面说过，函数必须先声明，后使用。由于程序总是先运行 <code>main()</code> 函数，导致所有其他函数都必须在 <code>main()</code> 函数之前声明。<br>但是，**<code>main()</code> 是整个程序的入口，也是主要逻辑**，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。</p></blockquote><p>C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以<strong>先使用、后声明</strong>。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型<br>函数原型必须<strong>以分号结尾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">twice</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>  <span class="hljs-keyword">return</span> twice(num);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">twice</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123; <span class="hljs-comment">//声明函数原型时可以带上变量</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * num;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-exit"><a href="#6-exit" class="headerlink" title="6. exit()"></a>6. exit()</h1><blockquote><p><code>exit()</code> 函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件 <code>stdlib.h</code> 里面。<br><code>exit()</code> 可以<strong>向程序外部返回一个值</strong>，它的<strong>参数</strong>就是程序的返回值。一般来说，使用两个常量作为它的参数：**<code>EXIT_SUCCESS</code>（相当于 0）** 表示程序运行成功，**<code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止**。这两个常数也是定义在 <code>stdlib.h</code> 里面。</p></blockquote><p>在 <code>main()</code> 函数里面，<code>exit()</code> 等价于使用 <code>return</code> 语句。其他函数使用 <code>exit()</code>，就是终止整个程序的运行，没有其他作用。<br>C 语言还提供了一个 <code>atexit()</code> 函数，用来<strong>登记 <code>exit()</code> 执行时额外执行的函数</strong>，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件 <code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">atexit</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int atexit(*print);</span><br><span class="hljs-comment">void (func)(void)&#123;</span><br><span class="hljs-comment">……</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p><code>atexit()</code> 的参数是一个函数指针。注意，<strong>它的参数函数不能接受参数</strong>，也不能有返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something wrong!\n&quot;</span>);<br>&#125;<br><br>atexit(print);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br></code></pre></td></tr></table></figure><h1 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a>函数说明符</h1><p>C 语言提供了一些函数说明符，让函数用法更加明确</p><h2 id="extern-说明符"><a href="#extern-说明符" class="headerlink" title="extern 说明符"></a>extern 说明符</h2><p>对于多文件的项目，源码文件会<strong>用到其他文件声明的函数</strong>。这时，当前文件里面，需要<strong>给出外部函数的原型</strong>，并用 <code>extern</code> 说明该函数的定义来自其他文件。</p><h2 id="static-说明符"><a href="#static-说明符" class="headerlink" title="static 说明符"></a>static 说明符</h2><p>默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。<code>static</code> 说明符可以改变这种行为。<br><code>static</code> 用于<strong>函数内部声明变量</strong>时，表示该变量<strong>只需要初始化一次</strong>，不需要在每次调用时都进行初始化。也就是说，它的<strong>值在两次调用之间保持不变</strong>。(此时多次调用该函数，可以起到类似循环的效果)</p><p>块作用域中，<code>static</code>声明的变量有默认值<code>0</code></p><p><code>static</code> 可以用来修饰函数本身。<br>此时 <code>static</code> 关键字表示该函数只能在当前文件里使用</p><p><code>static</code> 修饰的变量初始化时，<strong>只能赋值为常量</strong>，不能赋值为变量<br><code>static int x = i</code> 为错误范例，应将 <code>i</code> 替换为常量</p><p><code>static</code> 也可以用在参数里面，修饰参数数组</p><h2 id="const-说明符"><a href="#const-说明符" class="headerlink" title="const 说明符"></a>const 说明符</h2><p>函数参数里面的 <code>const</code> 说明符，表示函数内部不得修改该参数变量。<br>即使得声明变量时加上了 const 说明符的变量在函数内部为常量</p><p>典型实例：<br>函数 <code>f()</code> 的参数是一个指针 <code>p</code>，函数内部可能会改掉它所指向的值 <code>*p</code>，从而影响到函数外部。因此，在指针参数前面加上 <code>const</code> 说明符，告诉编译器，函数内部不能修改该参数所指向的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> &#123;<br>  *p = <span class="hljs-number">0</span>; <span class="hljs-comment">// 修改无效</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是此种写法只限制了修改 p 指向的值（即只限定 <code>*p</code> 不能修改。），仍旧能修改其地址 <code>p = &amp;x</code>；同理，如果想限制修改 <code>p</code>，可以把 <code>const</code> 放在 <code>p</code> 前面（此时地址不能修改但是该地址对应的值可以被修改）。<br>而如果想同时限制修改 <code>p</code> 和 <code>*p</code>，需要使用两个 <code>const</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p)</span> &#123;<br></code></pre></td></tr></table></figure><h1 id="8-可变参数"><a href="#8-可变参数" class="headerlink" title="8. 可变参数"></a>8. 可变参数</h1><blockquote><p>有些函数的<strong>参数数量是不确定的</strong>，声明函数的时候，可以使用省略号 <code>...</code> 表示可变数量的参数。<br>注意，<code>...</code> 符号必须放在<strong>参数序列的结尾</strong>，否则会报错。</p></blockquote><p><code>stdarg.h</code> 定义了一些宏，可以 [[头文件&#x2F;stdarg.h#操作可变参数|操作可变参数]]</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.运算符</title>
    <link href="/2024/02/24/%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2024/02/24/%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h1><table><thead><tr><th>运算符</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>+</td><td>正值运算符</td><td>一元运算符</td></tr><tr><td>-</td><td>负值运算符</td><td>一元运算符</td></tr><tr><td>+</td><td>加法运算符</td><td>二元运算符</td></tr><tr><td>-</td><td>减法运算符</td><td>二元运算符</td></tr><tr><td>*</td><td>乘法运算符</td><td></td></tr><tr><td>&#x2F;</td><td>除法运算符</td><td></td></tr><tr><td>%</td><td>余值运算符</td><td></td></tr></tbody></table><h2 id="，"><a href="#，" class="headerlink" title="+，-"></a><code>+</code>，<code>-</code></h2><blockquote><p>这两者可作为一元运算符和二元运算符</p></blockquote><ul><li>作为一元运算符时<ul><li><code>+</code> 对正负值没有影响，可省略</li><li><code>-</code> 用来改变一个值的正负号。</li></ul></li><li>作为二元运算符<ul><li>完成加法和减法</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title="*"></a><code>*</code></h2><blockquote><p>运算符 <code>*</code> 用来完成乘法。</p></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title="/"></a><code>/</code></h2><blockquote><p>运算符 <code>/</code> 用来完成除法</p></blockquote><p>C 语言里面的整数除法是整除，<strong>只会返回整数部分，丢弃小数部分</strong>。<br>无论<strong>变量类型如何</strong>（整数或是浮点数），整数之间的除法都将遵照此规定。<br>当相除的两数<strong>有至少一个是浮点数</strong>时，使用 <code>/</code> 将会进行浮点数除法并返还浮点数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> score = <span class="hljs-number">5</span>;<br>score = (score / <span class="hljs-number">20</span>) * <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>上面的代码，你可能觉得经过运算，<code>score</code> 会等于 <code>25</code>，但是实际上 <code>score</code> 等于 <code>0</code>。这是因为 <code>score / 20</code> 是整除，会得到一个整数值 <code>0</code>，所以乘以 <code>100</code> 后得到的也是 <code>0</code>。<br>为了得到预想的结果，可以将除数 <code>20</code> 改成 <code>20.0</code>，让整除变成浮点数除法。</p><h2 id="-2"><a href="#-2" class="headerlink" title="%"></a><code>%</code></h2><blockquote><p>运算符 <code>%</code> 表示求模运算，即返回两个整数相除的余值。这个运算符&#x3D;&#x3D;只能用于整数，不能用于浮点数&#x3D;&#x3D;。同 python </p></blockquote><p><strong>关于负数求模</strong>  &#x3D;&#x3D;结果&#x3D;&#x3D;的正负号由&#x3D;&#x3D;第一个运算数的正负号&#x3D;&#x3D;决定</p><h2 id="赋值运算的简写形式"><a href="#赋值运算的简写形式" class="headerlink" title="赋值运算的简写形式"></a>赋值运算的简写形式</h2><p>同 [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#7. 用户输入和 while 循环 e057a9 赋值运算符|python]]</p><h1 id="2-自增运算符，自减运算符"><a href="#2-自增运算符，自减运算符" class="headerlink" title="2.自增运算符，自减运算符"></a>2.自增运算符，自减运算符</h1><blockquote><p>C 语言提供两个运算符，对变量自身进行 <code>+ 1</code> 和 <code>- 1</code> 的操作。</p></blockquote><ul><li><code>++</code>：自增运算符</li><li><code>--</code>：自减运算符</li></ul><p>自增&#x2F;减运算符</p><ul><li>在变量&#x2F;值之&#x3D;&#x3D;前&#x3D;&#x3D;表示先执行对变量自身的自加减，再&#x3D;&#x3D;<strong>对已处理过的值进行操作</strong>&#x3D;&#x3D;</li><li>在变量&#x2F;值之&#x3D;&#x3D;后&#x3D;&#x3D;表示先&#x3D;&#x3D;<strong>操作未处理前的值</strong>&#x3D;&#x3D;，再进行自加减</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> j;<br><br>j = (i++ + <span class="hljs-number">10</span>);<br><span class="hljs-comment">// i: 43</span><br><span class="hljs-comment">// j: 52，在返回 j 的值时，参与计算的是未进行自加减的 i </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> j;<br><br>j = (++i + <span class="hljs-number">10</span>)<br><span class="hljs-comment">// i: 43</span><br><span class="hljs-comment">// j: 53 在返回 j 的值时，参与计算的是已进行自加减的 i</span><br></code></pre></td></tr></table></figure><p>为消除意外，可使用如下写法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 写法一，改写法参与计算的是未进行自加减的 i ，等同于上面的 j = (i++ + 10) */</span><br>j = (i + <span class="hljs-number">10</span>);<br>i++;<br><br><span class="hljs-comment">/* 写法二，改写法参与计算的是已u进行自加减的 i ，等同于上面的 j = (++i + 10) */</span><br>i++;<br>j = (i + <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h1 id="3-关系运算符"><a href="#3-关系运算符" class="headerlink" title="3.关系运算符"></a>3.关系运算符</h1><blockquote><p>同 [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#比较 （关系）运算符|python 的比较关系运算符]] ，但是 C 返回的是 <code>0</code> 或 <code>1</code></p></blockquote><p>多个关系运算符不宜连用，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">i &lt; j &lt; k<br></code></pre></td></tr></table></figure><p>虽然连续使用两个小于运算符，是合法表达式。但是关系运算符是从左到右计算，所以实际执行的是 <code>(i &lt; j) &lt; k</code>，而 <code>(i &lt; j)</code> 实际返回的是0&#x2F;1，所以比较的是 0&#x2F;1 与 k 的大小关系</p><p>如果想要判断变量 <code>j</code> 的值是否在 <code>i</code> 和 <code>k</code> 之间，应该使用逻辑运算符。</p><h1 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h1><blockquote><p>逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。</p></blockquote><ul><li><code>!</code>：否运算符（改变单个表达式的真伪）。</li><li><code>&amp;&amp;</code>：与运算符（两侧的表达式都为真，则为真，否则为伪）。</li><li><code>||</code>：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。<br>[[..&#x2F;Computer Science&#x2F;2.布尔代数|布尔代数]]</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//否运算符实例</span><br><span class="hljs-keyword">if</span> (!(x &lt; <span class="hljs-number">12</span>))<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x is not less than 12\n&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>逻辑运算符的一个特点：<br>总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。<br>如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。</p></blockquote><h1 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h1><blockquote><p>C 语言提供一些位运算符，用来操作二进制位（bit）。</p></blockquote><h2 id="取反运算符-～"><a href="#取反运算符-～" class="headerlink" title="取反运算符 ～"></a>取反运算符 <code>～</code></h2><blockquote><p>取反运算符 <code>～</code> 是一个一元运算符，用来将每一个二进制位变成相反值，即 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回 01101100</span><br>~ <span class="hljs-number">10010011</span><br></code></pre></td></tr></table></figure><h2 id="与运算符"><a href="#与运算符" class="headerlink" title="与运算符 &amp;"></a>与运算符 <code>&amp;</code></h2><blockquote><p>与运算符 <code>&amp;</code> 将两个值的&#x3D;&#x3D;<strong>每一个二进制位</strong>&#x3D;&#x3D;进行比较，返回一个新的值。当两个二进制位都为 <code>1</code>，就返回 <code>1</code>，否则返回 <code>0</code>。<br>与运算符 <code>&amp;</code> 可以与赋值运算符 <code>=</code> 结合，简写成 <code>&amp;=</code></p></blockquote><h2 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符 |"></a>或运算符 <code>|</code></h2><blockquote><p>或运算符 <code>|</code> 将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为 <code>1</code>（包含两个都为 <code>1</code> 的情况），就返回 <code>1</code>，否则返回 <code>0</code>。<br>或运算符 <code>|</code> 可以与赋值运算符 <code>=</code> 结合，简写成 <code>|=</code></p></blockquote><h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符 ^"></a>异或运算符 <code>^</code></h2><blockquote><p>异或运算符 <code>^</code> 将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为 <code>1</code>，就返回 <code>1</code>，否则返回 <code>0</code>。<br>异或运算符<code>^</code>可以与赋值运算符<code>=</code>结合，简写成<code>^=</code>。</p></blockquote><h2 id="-3"><a href="#-3" class="headerlink" title="&amp; ,  |,  ^"></a><code>&amp;</code> ,  <code>|</code>,  <code>^</code></h2><p>类似于[[..&#x2F;Computer Science&#x2F;2.布尔代数|逻辑门]]中的 AND 门，OR 门，XOR 门</p><h2 id="6-右移运算符"><a href="#6-右移运算符" class="headerlink" title="6. 右移运算符"></a>6. 右移运算符</h2><blockquote><p>右移运算符 <code>&gt;&gt;</code> 将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用 <code>0</code> 填充。<br>最好<strong>只用于无符号整数</strong>，<strong>不要用于负数</strong>。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。<br>右移运算符<code>&gt;&gt;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&gt;&gt;=</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回 00100010</span><br><span class="hljs-number">10001010</span> &gt;&gt; <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>10001010</code> 的每一个二进制位，都向右移动两位。最低的两位 <code>10</code> 被丢弃，头部多出来的两位补 <code>0</code>，所以最后得到 <code>00100010</code>。</p><h1 id="7-逗号运算符"><a href="#7-逗号运算符" class="headerlink" title="7. 逗号运算符"></a>7. 逗号运算符</h1><blockquote><p>逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。<br>逗号运算符返回最后一个表达式的值，作为整个语句的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x;<br><br>x = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>上面示例中，括号里面的逗号运算符，返回最后一个表达式的值，所以变量 <code>x</code> 等于 <code>3</code>。</p><h1 id="8-运算优先级"><a href="#8-运算优先级" class="headerlink" title="8. 运算优先级"></a>8. 运算优先级</h1><ol><li>优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行。各种运算符的优先级是不一样的。</li><li>如果两个运算符优先级相同，则根据运算符是左结合，还是右结合，决定执行顺序。大部分运算符是左结合（从左到右执行），少数运算符是右结合（从右到左执行），比如赋值运算符（<code>=</code>）。 </li><li>按照优先级从高到低排列：<ol><li>圆括号（<code>()</code>）</li><li>自增运算符（<code>++</code>），自减运算符（<code>--</code>）</li><li>一元运算符（<code>+</code> 和 <code>-</code>）</li><li>乘法（<code>*</code>），除法（<code>/</code>）</li><li>加法（<code>+</code>），减法（<code>-</code>）</li><li>关系运算符（<code>&lt;</code>、<code>&gt;</code> 等）</li><li>赋值运算符（<code>=</code>）<br> [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#数值运算的运算优先级及括号的用法|优先级与 python 对比]]</li></ol></li></ol><p>&#x3D;&#x3D;<strong>完全记住所有运算符的优先级没有必要，解决方法是多用圆括号，防止出现意料之外的情况，也有利于提高代码的可读性。</strong>&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.字符串</title>
    <link href="/2024/02/24/%E4%B9%9D%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/02/24/%E4%B9%9D%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p>C 语言<strong>没有单独的字符串类型</strong>，字符串<strong>被当作&#x3D;&#x3D;字符&#x3D;&#x3D;数组</strong>，<strong>即 <code>char</code> 类型的数组</strong>。比如，字符串“Hello”是当作数组 <code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125;</code> 处理的。</p><p>编译器会给数组分配一段连续内存，<strong>所有字符储存在相邻的内存单元之中</strong>。在<strong>字符串结尾，C 语言会自动添加一个全是二进制 <code>0</code> 的字节</strong>，<strong>写作 <code>\0</code> 字符</strong>，表示<strong>字符串结束</strong>。字符 <code>\0</code> 不同于字符 <code>0</code>，两者的 ASCII 码不同，前者的是0（二进制形式 <code>00000000</code>）。所以，字符串“Hello”实际储存的数组是 <code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;</code>。</p><p><strong>所有字符串的最后一个字符，都是 <code>\0</code><strong>。这样做的好处是，</strong>C 语言不需要知道字符串的长度，就可以读取内存里面的字符串</strong>，只要发现有一个字符是 <code>\0</code>，那么就知道字符串结束了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> localString[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>上面示例声明了一个10个成员的字符数组，可以当作字符串。由于必须留一个位置给 <code>\0</code>，所以<strong>最多只能容纳9个字符的字符串</strong>。</p><p>&#x3D;&#x3D;<strong>双引号之中</strong>的字符，会被<strong>自动视为字符数组</strong>。&#x3D;&#x3D;</p><p>双引号里面是字符串，单引号里面是字符（[[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型|python]] 中，英文引号引起的都是字符串）[[杂项&#x2F;字符与字符串#字符与字符串的对比|字符与字符串]] #C语言与python的区别 </p><p>如果字符串<strong>内部包含双引号</strong>，则该双引号需要&#x3D;&#x3D;使用反斜杠转义&#x3D;&#x3D;。</p><p>C 语言允许合并多个字符串字面量，只要这些<strong>字符串之间没有间隔</strong>，或者<strong>只有空格</strong>，C 语言会将它们自动合并。效果类似 python 的 [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#2.3.2 f-字符串|f 字符串]] #C语言与python的区别 </p><h1 id="2-字符串变量的声明"><a href="#2-字符串变量的声明" class="headerlink" title="2. 字符串变量的声明"></a>2. 字符串变量的声明</h1><blockquote><p>字符串变量可以<strong>声明成一个字符数组</strong>，也可以<strong>声明成一个指针</strong>，指向字符数组。</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 写法一<br>char s[<span class="hljs-number">14</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><span class="hljs-comment">;</span><br><br>// 写法二<br>char* s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面两种写法都声明了一个字符串变量 <code>s</code>。如果采用第一种写法，由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度</p><p><strong>字符数组</strong>的<strong>长度</strong>，可以<strong>大于</strong>字符串的<strong>实际长度</strong>，但是<strong>不能小于</strong>字符串的<strong>实际长度</strong><br>空出来的位置会被<strong>初始化为 <code>\0</code></strong></p><p><strong>字符指针和字符数组</strong>，这两种声明字符串变量的<strong>写法基本是等价的</strong>，但是有<strong>两个差异</strong>。</p><ol><li><strong>指针指向的字符串</strong>，在 C 语言内部<strong>被当作常量</strong>，<strong>不能修改</strong>字符串<strong>本身</strong><ol><li>声明为指针时，系统会将字符串的字面量保存再内存的<strong>常量区</strong><br>字符串<strong>声明为指针后不得修改</strong>，可以在声明时<strong>使用<code>const</code>说明符</strong>，保证该字符串<strong>是只读的</strong>。</li><li>声明为数组时，编译器会为数组<strong>单独分配一段内存</strong></li></ol></li><li><strong>指针</strong>变量<strong>可以指向其它字符串</strong>。<ol><li>字符指针可以指向另一个字符串。</li><li>字符数组变量不能指向另一个字符串。<br>字符数组的<strong>数组名</strong>，<strong>总是</strong>指向<strong>初始化时的字符串地址</strong>，不能修改。<br>（字符数组的变量名，跟所指向的数组是<strong>绑定</strong>的，不能指向另一个地址）</li><li><strong>数组变量</strong>是一个<strong>不可修改的左值</strong>，即不能用赋值运算符为它重新赋值。<br>想要重新赋值，必须使用 C 语言原生提供的 <code>strcpy()</code> 函数，通过字符串拷贝完成赋值。数组变量的<strong>地址还是不变的</strong>，即 <code>strcpy()</code> 只是<strong>在原地址写入新的字符串</strong>，而不是让数组变量指向新的地址。</li></ol></li></ol><h1 id="3-strlen"><a href="#3-strlen" class="headerlink" title="3. strlen()"></a>3. <code>strlen()</code></h1><blockquote><p><code>strlen()</code> 函数<strong>返回字符串的字节长度</strong>，**不包括末尾的空字符 <code>\0</code>**。<br><code>strlen()</code>的原型在标准库的<code>string.h</code>文件中定义，使用时需要加载头文件<code>string.h</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// string.h</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span>;<br></code></pre></td></tr></table></figure><p>它的<strong>参数是字符串变量</strong>，返回的是 <code>size_t</code> 类型的无符号整数，除非是极长的字符串，一般情况下当作 <code>int</code> 类型处理即可</p><p>字符串长度（<code>strlen()</code>）与字符串变量长度（<code>sizeof()</code>），是两个不同的概念。<br>[[五、数据类型#8. sizeof 运算符|sizeof()]]</p><h1 id="4-strcpy"><a href="#4-strcpy" class="headerlink" title="4. strcpy()"></a>4. strcpy()</h1><blockquote><p>字符串的<strong>复制不能使用赋值运算符</strong>，直接将一个字符串赋值给字符数组变量。</p><blockquote><p>数组的<strong>变量名是一个固定的地址</strong>，不能修改，使其指向另一个地址。</p><p>如果是<strong>字符指针</strong>，赋值运算符（<code>=</code>）只是<strong>将一个指针的地址</strong>&#x3D;&#x3D;复制&#x3D;&#x3D;给另一个指针，而不是复制字符串。<strong>此时两个指针变量指向的时同一字符串</strong>，即<strong>内存中</strong>只有一份字符串，并非事实意义上的复制</p></blockquote></blockquote><p><code>strcpy()</code>函数，用于将一个字符串的<strong>内容复制</strong>到另一个字符串，相当于字符串赋值。该函数的原型定义在<code>string.h</code>头文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">strcpy</span>(<span class="hljs-type">char</span> dest[], <span class="hljs-type">const</span> <span class="hljs-type">char</span> source[])<br></code></pre></td></tr></table></figure><p>该函数接受两个参数</p><ol><li>目的字符串数组</li><li>源字符串数组</li></ol><p>同时应满足第一个参数的长度<strong>不小于</strong>第二个参数</p><p>第二个参数的 <code>const</code> 说明符，表示这个<strong>函数不会修改</strong>第二个字符串。</p><p><code>strcpy()</code>也可以<strong>用于字符数组的赋值</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;abcd&quot;</span>);<span class="hljs-comment">//将 a,b,c,d 放入了长度为10的字符串数组</span><br></code></pre></td></tr></table></figure><p><code>strcpy()</code> 的<strong>第一个参数</strong>最好是一个<strong>已经声明的数组</strong>，而不是声明后没有进行初始化的字符指针。<br><strong>未进行初始化</strong>的数组，指向的是一个<strong>随机的</strong>位置，因此字符串可能被复制到任意地方。<br><code>strcpy()</code> 的返回值是一个字符串指针（即 <code>char*</code>），指向第一个参数。</p><p><code>strcpy()</code> 函数有安全风险，因为它并<strong>不检查目标字符串的长度</strong>，不判断<strong>是否足够容纳源字符串的副本</strong>，可能<strong>导致写入溢出</strong>。<br>而 <code>strncpy()</code> 函数则可避免此风险</p><h1 id="5-strncpy"><a href="#5-strncpy" class="headerlink" title="5. strncpy()"></a>5. strncpy()</h1><blockquote><p><code>strncpy()</code> 跟 <code>strcpy()</code> 的用法完全一样，只是<strong>多了&#x3D;&#x3D;第3个参数</strong>&#x3D;&#x3D;，用来<strong>指定复制的最大字符数</strong>，防止溢出目标字符串变量的边界。<br>也可以用来<strong>拷贝部分字符串。</strong></p></blockquote><p>如果达到最大字符数以后，源字符串仍然没有复制完，就会<strong>停止复制</strong>，这时目的字符串&#x3D;&#x3D;<strong>结尾将没有终止符 <code>\0</code></strong>&#x3D;&#x3D;</p><h1 id="6-strcat"><a href="#6-strcat" class="headerlink" title="6. strcat()"></a>6. strcat()</h1><blockquote><p><code>strcat()</code> 函数用于连接字符串。它接受<strong>两个字符串作为参数</strong>，把<strong>第二个字符串的&#x3D;&#x3D;副本&#x3D;&#x3D;添加到第一个字符串的&#x3D;&#x3D;末尾&#x3D;&#x3D;<strong>。这个函数</strong>会改变第一个字符串</strong>，但是<strong>第二个字符串不变</strong>（因为是复制）。<br>返回值是一个字符串指针，<strong>指向第一个参数</strong>。</p></blockquote><p><code>strcat()</code> 的第一个参数的长度，<strong>必须足以容纳</strong>添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元<br>同样，可以使用 <code>strncat()</code> 避免此类风险</p><h1 id="7-strncat"><a href="#7-strncat" class="headerlink" title="7. strncat()"></a>7. strncat()</h1><blockquote><p><strong>用法与 <code>strcat()</code> 完全一致</strong>，只是增加了第三个参数，指定最大添加的字符数。<br>添加过程中，一旦<strong>达到指定的字符数</strong>，或者在<strong>源字符串中遇到空字符 <code>\0</code><strong>，就不再添加了<br>返回值是一个字符串指针，</strong>指向第一个参数</strong>。</p></blockquote><p>为了保证连接后的字符串，不超过目标字符串的长度，<code>strncat()</code>通常会写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">strncat</span>(<br>  str1, <br>  str2, <br>  <span class="hljs-keyword">sizeof</span>(str1) - <span class="hljs-built_in">strlen</span>(str1) - <span class="hljs-number">1</span><br>);<br></code></pre></td></tr></table></figure><p><code>strncat()</code> 总是会在拼接结果的结尾，自动添加空字符 <code>\0</code>，所以第三个参数的最大值，应该是 <code>str1</code> 的变量长度减去 <code>str1</code> 的字符串长度，再减去 <code>1</code></p><h1 id="8-strcmp"><a href="#8-strcmp" class="headerlink" title="8.strcmp()"></a>8.strcmp()</h1><blockquote><p><code>strcmp()</code>函数用于比较两个字符串的内容。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span>* s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2)</span>;<br></code></pre></td></tr></table></figure><p>按照<strong>字典顺序</strong>，如果两个<strong>字符串相同</strong>，<strong>返回值为 <code>0</code></strong> 如果 <code>s1</code> <strong>小于</strong> <code>s2</code>，<code>strcmp()</code> <strong>返回值小于0</strong>；如果 <code>s1</code> <strong>大于</strong> <code>s2</code>，<strong>返回值大于0。</strong></p><p><strong>只用来比较字符串</strong>，不用来比较字符，不要把字符类型（<code>char</code>）的值，放入 <code>strcmp()</code> 当作参数。</p><h1 id="9-strncmp"><a href="#9-strncmp" class="headerlink" title="9. strncmp()"></a>9. strncmp()</h1><blockquote><p>由于 <code>strcmp()</code> 比较的是<strong>整个字符串</strong>，C 语言又提供了 <code>strncmp()</code> 函数，只比较到指定的位置。<br>该函数增加了<strong>第三个参数</strong>，**指定了&#x3D;&#x3D;比较的字符数&#x3D;&#x3D;**。<br>其他与 <code>strcmp()</code> 一致</p></blockquote><h1 id="10-sprintf-，snprintf"><a href="#10-sprintf-，snprintf" class="headerlink" title="10. sprintf()，snprintf()"></a>10. sprintf()，snprintf()</h1><blockquote><p><code>sprintf()</code> 函数跟 <code>printf()</code> 类似，但是用于<strong>将数据写入字符串</strong>，而不是输出到显示器。该函数的原型定义在 <code>stdio.h</code> 头文件里面。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>;<br></code></pre></td></tr></table></figure><p><code>sprintf()</code> 的<strong>第一个参数</strong>是<strong>字符串指针变量</strong>（即要被写入数据的字符数组），其余参数和 <code>printf()</code> 相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。</p><p><strong>返回值</strong>是<strong>写入变量的字符数量</strong>（<strong>不计</strong>入尾部的<strong>空字符 <code>\0</code><strong>）。如果</strong>遇到错误，返回负值</strong>。<br><code>sprintf()</code> 有严重的安全风险，如果写入的字符串过长，超过了目标字符串的长度，<code>sprintf()</code> 依然会将其写入，导致发生溢出。</p><p><strong><code>snprintf()</code></strong> 只比 <code>sprintf()</code> 多了**一个参数 <code>n</code>**，用来控制写入变量的字符串不超过 <code>n - 1</code> 个字符，剩下一个位置写入空字符 <code>\0</code>。（与前面几个不同，多出来的参数是写在中间的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">snprintf</span><span class="hljs-params">(<span class="hljs-type">char</span>*s, <span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>;<br></code></pre></td></tr></table></figure><p><code>snprintf()</code><strong>总是会自动写入字符串结尾的空字符</strong>。如果你尝试写入的字符数<strong>超过指定的最大字符数</strong>，<code>snprintf()</code> 会写入 n - 1 个字符，<strong>留出最后一个位置写入空字符</strong>。</p><p><strong>返回值</strong>是<strong>写入格式字符串的字符数量</strong>（<strong>不计入</strong>尾部的**空字符 <code>\0</code>**）</p><h1 id="11-字符串数组"><a href="#11-字符串数组" class="headerlink" title="11. 字符串数组"></a>11. 字符串数组</h1><blockquote><p>如果一个数组的每个成员都是一个字符串，需要通过<strong>二维的字符数组</strong>实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。<br>第二维的长度统一为最长的那个（<strong>包括 <code>\0</code> 且必须指定</strong>）<br>而第一维的长度将被<strong>自动计算</strong></p></blockquote><p>数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是<strong>把数组的第二维，从字符数组改成字符指针。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* weekdays[] = &#123;<br>  <span class="hljs-string">&quot;Monday&quot;</span>,<br>  <span class="hljs-string">&quot;Tuesday&quot;</span>,<br>  <span class="hljs-string">&quot;Wednesday&quot;</span>,<br>  <span class="hljs-string">&quot;Thursday&quot;</span>,<br>  <span class="hljs-string">&quot;Friday&quot;</span>,<br>  <span class="hljs-string">&quot;Saturday&quot;</span>,<br>  <span class="hljs-string">&quot;Sunday&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的字符串数组，其实是一个<strong>一维数组</strong>，<strong>成员</strong>就是<strong>7个字符指针</strong>，每个指针<strong>指向一个字符串（字符数组）。</strong></p><p>遍历字符串数组的写法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, weekdays[i]);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="各函数对比"><a href="#各函数对比" class="headerlink" title="各函数对比"></a>各函数对比</h1><table><thead><tr><th align="left">函数名称</th><th align="left">作用</th><th align="left">头文件</th><th>存在溢出风险</th><th>操作结束后是否会添加<code>\0</code></th><th>返回值</th></tr></thead><tbody><tr><td align="left">strcpy()</td><td align="left">复制字符串的内容</td><td align="left">string.h</td><td>√</td><td>×</td><td>指向第一个参数（复制目标）的指针</td></tr><tr><td align="left">strncpy()</td><td align="left">复制字符串（不超出第一个参数容量）的内容</td><td align="left">string.h</td><td>×</td><td>×</td><td>指向第一个参数（复制目标）的指针</td></tr><tr><td align="left">strcat()</td><td align="left">连接（不超出第一个参数容量）两个字符串</td><td align="left">string.h</td><td>√</td><td>×</td><td>指向第一个参数的指针</td></tr><tr><td align="left">strncat()</td><td align="left">连接两个字符串</td><td align="left">string.h</td><td>×</td><td>√</td><td>指向第一个参数的指针</td></tr><tr><td align="left">strcmp()</td><td align="left">比较两个字符串的内容</td><td align="left">string.h</td><td>√</td><td>\</td><td>两个字符串相同，返回0</td></tr><tr><td align="left">strncmp()</td><td align="left">比较两个字符串（指定长度）的内容</td><td align="left">string.h</td><td>×</td><td>\</td><td>同strcmp()</td></tr><tr><td align="left">sprintf()</td><td align="left">将数据写入字符串</td><td align="left"><strong>stdio.h</strong></td><td>√</td><td>×</td><td>写入变量的字符数，遇到错误，<strong>返回负值</strong>。</td></tr><tr><td align="left">snprintf()</td><td align="left">将数据写入（不超出第一个参数容量的）字符串</td><td align="left"><strong>stdio.h</strong></td><td>×</td><td>√</td><td>写入变量的字符数，遇到错误，<strong>返回负值</strong>。</td></tr><tr><td align="left">strlen()</td><td align="left">返回字符串的字节长度</td><td align="left">string.h</td><td>\</td><td>\</td><td>返回字符串的<strong>字节长度</strong>，不包括末尾的空字符 <strong><code>\0</code></strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.数据类型</title>
    <link href="/2024/02/24/%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/02/24/%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。复杂的类型都是基于它们构建的。</p></blockquote><h1 id="1-字符类型"><a href="#1-字符类型" class="headerlink" title="1. 字符类型"></a>1. 字符类型</h1><p>字符类型指的是单个字符，&#x3D;&#x3D;<strong>类型声明使用 <code>char</code> 关键字</strong>&#x3D;&#x3D;。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;B&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面示例声明了变量<code>c</code>是字符类型，并将其赋值为字母<code>B</code>。<br>C 语言规定，字符常量必须放在<strong>单引号</strong>里面。</p><p>计算机内部，字符类型使用一个字节（8位）存储。C 语言将其当作整数处理，所以字符类型就是宽度为一个字节的整数。每个字符对应一个整数（由 ASCII 码确定），比如 <code>B</code> 对应整数 <code>66</code>。</p><p>因此<br>只要在<strong>字符类型的范围之内</strong>，<strong>整数与字符是可以互换</strong>的，都可以赋值给字符类型的变量<br>字符类型在不同计算机的默认范围是不一样的。一些系统默认为<code>-128</code>到<code>127</code>，另一些系统默认为<code>0</code>到<code>255</code>。这两种范围正好都能覆盖<code>0</code>到<code>127</code>的 ASCII 字符范围。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c = <span class="hljs-number">66</span>;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;B&#x27;</span>;<br></code></pre></td></tr></table></figure><p>同理，两个字符类型的变量<strong>可以进行数学运算</strong></p><p><strong>转义</strong>：单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义<br>[[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#转义字符|引申]]</p><p>转义写法还能使用八进制和十六进制表示一个字符。</p><ul><li><code>\nn</code>：字符的八进制写法，<code>nn</code>为八进制值。</li><li><code>\xnn</code>：字符的十六进制写法，<code>nn</code> 为十六进制值。</li></ul><h1 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>整数类型用来表示较大的整数，类型声明使用 <code>int</code> 关键字。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> a;<br></code></pre></td></tr></table></figure><p>不同计算机的 <code>int</code> 类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个 <code>int</code> 类型的值，但是2个字节（16位）或8个字节（64位）也有可能使用。它们可以表示的整数范围如下。</p><ul><li>16位：-32,768 到 32,767。</li><li>32位：-2,147,483,648 到 2,147,483,647。</li><li>64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li></ul><h2 id="signed，unsigned"><a href="#signed，unsigned" class="headerlink" title="signed，unsigned"></a>signed，unsigned</h2><blockquote><p>C 语言使用 <code>signed</code> 关键字，表示一个类型带有正负号，包含负值；使用 <code>unsigned</code> 关键字，表示该类型不带有正负号，只能表示零和正整数。<br>对于 <code>int</code> 类型，默认是带有正负号的，也就是说 <code>int</code> 等同于 <code>signed int</code>。由于这是默认情况，关键字 <code>signed</code> 一般都省略不写，但是写了也不算错。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">signed</span> <span class="hljs-type">int</span> a;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">int</span> a;<br></code></pre></td></tr></table></figure><p><strong>只表示非负整数</strong>。这时就必须使用关键字 <code>unsigned</code> 声明变量<br><code>unsigned int a;</code></p><p>整数变量声明为 <code>unsigned</code> 的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。比如，16位的 <code>signed int</code> 最大值为32,767，而 <code>unsigned int</code> 的最大值增大到了65,535。<br><strong>因为当包含正负号时需要用最左边的一位来确定正负</strong></p><h2 id="整数的子类型"><a href="#整数的子类型" class="headerlink" title="整数的子类型"></a>整数的子类型</h2><blockquote><p>C 语言在 <code>int</code> 类型之外，又提供了三个整数的子类型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图</p></blockquote><ul><li><code>short int</code>（简写为 <code>short</code>）：占用空间不多于 <code>int</code>，一般占用2个字节（整数范围为-32768～32767)。</li><li><code>long int</code>（简写为<code>long</code>）：占用空间不少于<code>int</code>，至少为4个字节。</li><li><code>long long int</code>（简写为 <code>long long</code>）：占用空间多于 <code>long</code>，至少为8个字节。</li></ul><blockquote><p>默认情况下，<code>short</code>、<code>long</code>、<code>long long</code> 都是带符号的（signed），即 <code>signed</code> 关键字省略了。它们也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。<br>同时 C 语言允许省略 <code>int</code> ,  <code>short a; </code> 与 <code>short int a;</code> 等效</p></blockquote><p>确实需要32位整数时，应使用 <code>long</code> 类型而不是 <code>int</code> 类型，可以确保不少于4个字节；确实需要64位的整数时，应该使用 <code>long long</code> 类型，可以确保不少于8个字节。另一方面，为了节省空间，只需要16位整数时，应使用 <code>short</code> 类型；需要8位整数时，应该使用 <code>char</code> 类型。</p><table><thead><tr><th>整数类型</th><th>位宽</th><th>最小字节数</th></tr></thead><tbody><tr><td><code>char</code></td><td>8 bits</td><td>1 byte</td></tr><tr><td><code>short</code></td><td>16 bits</td><td>2 bytes</td></tr><tr><td><code>long</code></td><td>32 bits</td><td>4 bytes</td></tr><tr><td><code>long long</code></td><td>64 bits</td><td>8 bytes</td></tr></tbody></table><h2 id="整数类型的极限值"><a href="#整数类型的极限值" class="headerlink" title="整数类型的极限值"></a>整数类型的极限值</h2><blockquote><p>有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件 <code>limits.h</code> 提供了相应的常量<br>   [[头文件&#x2F;<code>limits.h</code>#<code>limits.h</code> 中表示不同整数类型的最大值和最小值的常量|limits.h]]</p></blockquote><h2 id="整数的进制"><a href="#整数的进制" class="headerlink" title="整数的进制"></a>整数的进制</h2><blockquote><p>C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。<br>八进制使用 <code>0</code> 作为前缀，比如 <code>017</code>、<code>0377</code>。<br>十六进制使用 <code>0x</code> 或 <code>0X</code> 作为前缀，比如 <code>0xf</code>、<code>0X10</code>。<br>有些编译器使用 <code>0b</code> 前缀，表示二进制数，但不是标准。<br>不同的进制<strong>只是整数的书写方法</strong>，不会对整数的实际存储方式产生影响。<strong>所有整数都是二进制形式存储</strong>，跟书写方式无关。不同进制<strong>可以混合使用</strong><br>[[一、基本语法#6.2 占位符|printf() 的进制相关占位符]]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">012</span>; <span class="hljs-comment">// 八进制，相当于十进制的10</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0x1A2B</span>; <span class="hljs-comment">// 十六进制，相当于十进制的6699</span><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">0b101010</span>;<br></code></pre></td></tr></table></figure><h1 id="3-浮点数类型"><a href="#3-浮点数类型" class="headerlink" title="3. 浮点数类型"></a>3. 浮点数类型</h1><blockquote><p><strong>任何有小数点的数值</strong>，都会被编译器解释为浮点数。所谓“浮点数”就是使用 m * be（<strong>科学计数法</strong>） 的形式，存储一个数值，<code>m</code> 是小数部分，<code>b</code> 是基数（通常是 <code>2</code>），<code>e</code> 是指数部分。这种形式是精度和数值范围的一种结合，可以表示非常大或者非常小的数。</p><p>浮点数的类型声明使用 <code>float</code> 关键字，可以用来声明浮点数变量。 </p></blockquote><p><code>float</code> 类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号。<code>float</code> 类型<strong>至少能够提供（十进制的）6位有效数字</strong>，**指数部分的范围为（十进制的）<code>-37</code> 到 <code>37</code>**，即数值范围为 $10^{-37}$ 到 $10^{37}$。</p><p>另外两种更大的浮点数类型。</p><ul><li><code>double</code>：占用8个字节（64位），至少提供13位有效数字。</li><li><code>long double</code>：通常占用16个字节。</li></ul><p>由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面 <code>0.1 + 0.2</code> 并不等于 <code>0.3</code>，而是有一个很小的误差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><blockquote><p>C 语言允许使用科学计数法表示浮点数，使用字母 <code>e</code> 来分隔小数部分和指数部分。<br><code>e</code> 后面如果是加号 <code>+</code>，加号可以省略。注意，科学计数法里面 <code>e</code> 的前后，不能存在空格。<br>另外，科学计数法的小数部分如果是 <code>0.x</code> 或 <code>x.0</code> 的形式，那么 <code>0</code> 可以省略。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> x = <span class="hljs-number">123.456e+3</span>; <span class="hljs-comment">// 123.456 x 10^3</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">double</span> x = <span class="hljs-number">123.456e3</span>;<br><br><span class="hljs-number">0.3E6</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-number">.3E6</span><br><br><span class="hljs-number">3.0E6</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-number">3.E6</span><br></code></pre></td></tr></table></figure><h1 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4. 布尔类型"></a>4. 布尔类型</h1><blockquote><p>C 语言原来并没有为布尔值单独设置一个类型，而是使用整数 <code>0</code> 表示伪，所有非零值表示真。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (x) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x is true!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此处 x 为 1 则被判断为 true</p><p>C99 标准添加了类型 <code>_Bool</code>，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用 <code>0</code> 表示伪，<code>1</code> 表示真（<strong>此前是非 0 表示 true</strong>），下面是一个示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">_Bool</span> isNormal;<br><br>isNormal = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (isNormal)<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Everything is OK.\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>头文件 <code>stdbool.h</code> 定义了另一个类型别名 <code>bool</code>，并且定义了 <code>true</code> 代表 <code>1</code>、<code>false</code> 代表 <code>0</code>。只要加载这个头文件，就可以使用这几个关键字。<br>加载头文件 <code>stdbool.h</code> 以后，就可以使用 <code>bool</code> 定义布尔值类型，以及 <code>false</code> 和 <code>true</code> 表示真伪。（自行定义 true or false）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">//此处将 变量 flag 定义为了 false</span><br></code></pre></td></tr></table></figure><h1 id="5-字面量的类型"><a href="#5-字面量的类型" class="headerlink" title="5. 字面量的类型"></a>5. 字面量的类型</h1><p>字面量（literal）指的是代码里面直接出现的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>x</code> 是变量，<code>123</code> 就是字面量。</p><p>编译器必须为字面量指定数据类型，就像必须为变量指定数据类型一样<br>一般情况下，十进制整数字面量（比如 <code>123</code>）会被编译器指定为 <code>int</code> 类型。如果一个数值比较大，超出了 <code>int</code> 能够表示的范围，编译器会将其指定为 <code>long int</code>。如果数值超过了 <code>long int</code>，会被指定为 <code>unsigned long</code>。如果还不够大，就指定为 <code>long long</code> 或 <code>unsigned long long</code>。</p><h1 id="6-字面量后缀"><a href="#6-字面量后缀" class="headerlink" title="6. 字面量后缀"></a>6. 字面量后缀</h1><blockquote><p>有时候，程序员希望为字面量指定一个不同的类型。比如，编译器将一个整数字面量指定为 <code>int</code> 类型，但是程序员希望将其指定为 <code>long</code> 类型，这时可以为该字面量加上后缀 <code>l</code> 或 <code>L</code>，编译器就知道要把这个字面量的类型指定为 <code>long</code>。</p></blockquote><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">123L</span>;<br></code></pre></td></tr></table></figure><blockquote><p>从字面量 <code>123</code> 有后缀 <code>L</code>，编译器就会将其指定为 <code>long</code> 类型。这里 <code>123L</code> 写成 <code>123l</code>，效果也是一样的，但是建议优先使用 <code>L</code>，因为小写的 <code>l</code> 容易跟数字 <code>1</code> 混淆<br>八进制和十六进制的值，也可以使用后缀 <code>l</code> 和 <code>L</code> 指定为 Long 类型<br>如果希望指定为<strong>无符号整数</strong> <code>unsigned int</code>，可以使用后缀 <code>u</code> 或 <code>U</code>。<br><code>L</code> 和 <code>U</code> 可以结合使用，表示 <code>unsigned long</code> 类型。<code>L</code> 和 <code>U</code> 的&#x3D;&#x3D;大小写和组合顺序无所谓&#x3D;&#x3D;。<br>浮点数，编译器<strong>默认指定为 double 类型</strong>，如需修改需自行添加后缀 <code>f</code>（float）或 <code>l</code>（long double）。</p></blockquote><ul><li>常见字面量后缀<ul><li><code>f</code> 和 <code>F</code>：<code>float</code> 类型。</li><li><code>l</code>和<code>L</code>：对于整数是<code>long int</code>类型，对于小数是<code>long double</code>类型。</li><li><code>ll</code>和<code>LL</code>：Long Long 类型，比如<code>3LL</code>。</li><li><code>u</code> 和 <code>U</code>：表示 <code>unsigned int</code>，比如 <code>15U</code>、<code>0377U</code>。</li></ul></li></ul><h1 id="7-溢出"><a href="#7-溢出" class="headerlink" title="7. 溢出"></a>7. 溢出</h1><blockquote><p>每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。</p></blockquote><p>一般来说，编译器<strong>不会对溢出报错</strong>，会正常执行代码，但是会<strong>忽略</strong>多出来的二进制位，只保留剩下的位，但应&#x3D;&#x3D;<strong>避免溢出</strong>&#x3D;&#x3D;<br>&#x3D;&#x3D;避免溢出的最好方法就是将运算结果与类型的极限值进行比较&#x3D;&#x3D;。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ui;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sum;<br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">if</span> (sum + ui &gt; UINT_MAX) too_big();<br><span class="hljs-keyword">else</span> sum = sum + ui;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">if</span> (ui &gt; UINT_MAX - sum) too_big();<br><span class="hljs-keyword">else</span> sum = sum + ui;<br></code></pre></td></tr></table></figure><h1 id="8-sizeof-运算符"><a href="#8-sizeof-运算符" class="headerlink" title="8. sizeof 运算符"></a>8. sizeof 运算符</h1><blockquote><p><code>sizeof</code> 是 C 语言提供的一个运算符，<strong>返回某种数据类型或某个值占用的字节数量</strong>。它的参数可以是<strong>数据类型的关键字，也可以是变量名或某个具体的值</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 参数为数据类型</span><br><span class="hljs-type">int</span> x = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br><br><span class="hljs-comment">// 参数为变量</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">sizeof</span>(i);<br><br><span class="hljs-comment">// 参数为数值</span><br><span class="hljs-keyword">sizeof</span>(<span class="hljs-number">3.14</span>);<br></code></pre></td></tr></table></figure><p>上面的第一个示例，返回得到 <code>int</code> 类型占用的字节数量（通常是 <code>4</code> 或 <code>8</code>）。第二个示例返回整数变量占用字节数量，结果与前一个示例完全一样。第三个示例返回浮点数 <code>3.14</code> 占用的字节数量，由于浮点数的字面量一律存储为 double 类型，所以会返回 <code>8</code>，因为 double 类型占用的8个字节。</p><p>[[杂项&#x2F;sizeof 运算符的返回值#^957c16|sizeof 运算符的返回值]]</p><h1 id="9-类型的自动转换"><a href="#9-类型的自动转换" class="headerlink" title="9. 类型的自动转换"></a>9. 类型的自动转换</h1><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p>赋值运算符会自动将右边的值，转成左边变量的类型。</p><ul><li>浮点数赋值给整数变量<ul><li>C 语言直接丢弃小数部分，而不是四舍五入（截值）</li><li><code>int x = 3.14;</code> <code>X</code> 的值为 3</li></ul></li><li>整数赋值给浮点数变量<ul><li>加上个 <code>.0</code></li></ul></li><li>窄类型赋值给宽类型<ul><li>字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。</li><li>比如，<code>char</code>或<code>short</code>类型赋值给<code>int</code>类型，会自动提升为<code>int</code>。</li></ul></li><li>宽类型赋值给窄类型<ul><li>会发生类型降级，自动转为后者的类型</li><li>可能会发生截值（truncation），系统会自动<strong>截去多余的二进制位</strong></li></ul></li></ul><h2 id="混合类型的运算"><a href="#混合类型的运算" class="headerlink" title="混合类型的运算"></a>混合类型的运算</h2><p>不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算</p><p>转换规则如下：</p><ol><li>整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。</li><li>不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型</li><li>不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型<br>有时还会将带符号的类型<code>signed</code>转为无符号<code>unsigned</code><br>&#x3D;&#x3D;最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将 <code>signed int</code> 转为 <code>unsigned int</code>，可能不会得到预期的结果。&#x3D;&#x3D;</li></ol><h2 id="整数类型的运算"><a href="#整数类型的运算" class="headerlink" title="整数类型的运算"></a>整数类型的运算</h2><blockquote><p>两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于 <code>int</code> 的类型，运算结果会自动提升为 <code>int</code>。\</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>函数的参数和返回值，会自动转成函数定义里指定的类型。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dostuff</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)</span>;<br><br><span class="hljs-type">char</span> m = <span class="hljs-number">42</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> n = <span class="hljs-number">43</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> c = dostuff(m, n);<br></code></pre></td></tr></table></figure><p>上面示例中，参数变量 <code>m</code> 和 <code>n</code> 不管原来的类型是什么，都会转成函数 <code>dostuff()</code> 定义的参数类型。</p><h1 id="10-类型的显式转换"><a href="#10-类型的显式转换" class="headerlink" title="10. 类型的显式转换"></a>10. 类型的显式转换</h1><blockquote><p>原则上，应该避免类型的自动转换，防止出现意料之外的结果。C 语言提供了类型的显式转换，允许手动转换类型。<br>只要<strong>在一个值或变量的前面</strong>，<strong>使用圆括号</strong>指定类型<code>(type)</code>，就可以将这个值或变量转为指定的类型，这叫做“类型指定”（casting）。</p></blockquote><h1 id="11-可移植类型"><a href="#11-可移植类型" class="headerlink" title="11. 可移植类型"></a>11. 可移植类型</h1><blockquote><p>C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。<br>程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件 <code>stdint.h</code> 创造了一些新的 [[头文件&#x2F;<code>stdint.h</code>#<code>stdint.h</code> 中新的类型别名|类型别名]] 。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.变量</title>
    <link href="/2024/02/24/%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F/"/>
    <url>/2024/02/24/%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>变量（variable）可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。</p></blockquote><h1 id="1-变量名"><a href="#1-变量名" class="headerlink" title="1. 变量名"></a>1. 变量名</h1><p>变量名在 C 语言里面属于标识符（identifier）<br>命名规范</p><ul><li>只能由字母（包括大写和小写）、数字和下划线（<code>_</code>）组成。</li><li>不能以数字开头。</li><li>长度不能超过63个字符。<br>与 [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#2.2 变量|python 中的变量]]命名规范相同</li></ul><p>主要的关键字和保留字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>, <span class="hljs-keyword">break</span>, <span class="hljs-keyword">case</span>, <span class="hljs-type">char</span>, <span class="hljs-type">const</span>, <span class="hljs-keyword">continue</span>, <span class="hljs-keyword">default</span>, <span class="hljs-keyword">do</span>, <span class="hljs-type">double</span>, <span class="hljs-keyword">else</span>, <span class="hljs-keyword">enum</span>, <span class="hljs-keyword">extern</span>, <span class="hljs-type">float</span>, <span class="hljs-keyword">for</span>, <span class="hljs-keyword">goto</span>, <span class="hljs-keyword">if</span>, <span class="hljs-keyword">inline</span>, <span class="hljs-type">int</span>, <span class="hljs-type">long</span>, <span class="hljs-keyword">register</span>, restrict, <span class="hljs-keyword">return</span>, <span class="hljs-type">short</span>, <span class="hljs-type">signed</span>, <span class="hljs-keyword">sizeof</span>, <span class="hljs-type">static</span>, <span class="hljs-keyword">struct</span>, <span class="hljs-keyword">switch</span>, <span class="hljs-keyword">typedef</span>, <span class="hljs-keyword">union</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">void</span>, <span class="hljs-keyword">volatile</span>, <span class="hljs-keyword">while</span><br></code></pre></td></tr></table></figure><p>两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的</p><h1 id="2-变量的声明"><a href="#2-变量的声明" class="headerlink" title="2. 变量的声明"></a>2. 变量的声明</h1><p>#C语言与python的区别<br><strong>C 语言的变量必须&#x3D;&#x3D;先声明再使用&#x3D;&#x3D;，声明变量时需要将变量的类型告知编译器</strong><br>声明后变量的类型不可在运行时修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> height;<br><span class="hljs-type">int</span> height, width; <span class="hljs-comment">//同一类型的变量可在同一行声明类型</span><br></code></pre></td></tr></table></figure><h1 id="3-变量的赋值"><a href="#3-变量的赋值" class="headerlink" title="3. 变量的赋值"></a>3. 变量的赋值</h1><blockquote><p>C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。</p></blockquote><p><strong>赋值操作通过赋值运算符 <code>=</code> 完成</strong><br>可以先声明再赋值，也可在同一行完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num;<br>num = <span class="hljs-number">12</span>;<br><span class="hljs-comment">//或者</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">12</span>;<br><br><span class="hljs-comment">//多个相同类型变量的赋值</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>赋值表达式<strong>有返回值</strong>，等于等号右边的值</p><p>对于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x, y;<br><br>x = <span class="hljs-number">1</span>;<br>y = (x = <span class="hljs-number">2</span> * x);<span class="hljs-comment">//其中 x 先被赋为了 2*x 即 2，随后 2 成为了 y 的返回值</span><br></code></pre></td></tr></table></figure><blockquote><p>由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x, y, z, m, n;<br>x = y = z = m = n = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>一次为多个变量赋值。赋值运算符是从右到左执行，所以先为 <code>n</code> 赋值，然后依次为 <code>m</code>、<code>z</code>、<code>y</code> 和 <code>x</code> 赋值。这些变量的值都被赋为了 3 </p><p><strong>左值（left value）和右值（right value）</strong><br>左值一般是变量，右值一般是一个具体的值</p><h1 id="4-变量的作用域"><a href="#4-变量的作用域" class="headerlink" title="4.变量的作用域"></a>4.变量的作用域</h1><blockquote><p>作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。</p><blockquote><p>文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。<br>块作用域（block scope）指的是由大括号（<code>&#123;&#125;</code>）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<span class="hljs-comment">//文件作用域</span><br><br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">12</span>) &#123;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">99</span>; <span class="hljs-comment">//该变量位于块作用域</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, a, b);  <span class="hljs-comment">// 12 99</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);  <span class="hljs-comment">// 12，而文件作用域可在从声明位置开始的任何位置使用</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b);  <span class="hljs-comment">// 出错，块作用域只能在代码块内部可见</span><br></code></pre></td></tr></table></figure><p><strong>代码块出现嵌套时的情况</strong>：</p><ul><li>内层代码块可以使用外层声明的变量（类似于代码块内可以使用文件作用域中声明的变量）</li><li>但外层不可以使用内层声明的变量（而块作用域中声明的变量在代码块之外不可见）</li><li>如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。<ul><li>可以近似理解为 [[..&#x2F;python&#x2F;一、基础知识&#x2F;2.变量和简单的数据类型#2.2 变量|python中将始终记录最新的变量的值]]，但是变量只会在特定的代码块中被覆盖</li></ul></li></ul><blockquote><p>最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。<code>for</code> 循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.数组</title>
    <link href="/2024/02/24/%E5%85%AB%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <url>/2024/02/24/%E5%85%AB%E3%80%81%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>类似于储存单一类型值的 python [[..&#x2F;python&#x2F;一、基础知识&#x2F;3.列表简介|列表]]</p><blockquote><p>数组是一组相同类型的值，按照顺序储存在一起。数组通过<strong>变量名后加方括号</strong>表示，方括号里面是数组的成员数量。声明数组时，<strong>必须给出数组的大小</strong>。<br>实例：<code>int scores[100]</code> 声明了一个数组 <code>scores</code>，里面包含100个成员，每个成员都是 <code>int</code> 类型。</p></blockquote><p>数组的成员从 <code>0</code> 开始编号，所以数组 <code>scores[100]</code> 就是从第0号成员一直到第99号成员，最后一个成员的编号会比数组长度小 <code>1</code>。 &#x3D;&#x3D;差一行为&#x3D;&#x3D; ^15b51e</p><p>数组名后面使用方括号指定编号，就可以引用该成员。也可以通过该方式，对该位置进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">scores[<span class="hljs-number">0</span>] = <span class="hljs-number">13</span>;<br><span class="hljs-comment">//将数组中的第一个值设为 13</span><br></code></pre></td></tr></table></figure><p>引用不存在的数组成员（即<strong>越界访问数组</strong>），并<strong>不会报错</strong><br>引用此位置并不会报错，会正常运行，使得<strong>紧跟在数组后面的那块内存区域被赋值</strong>，而那<strong>实际上是其他变量的区域</strong>，因此不知不觉就<strong>更改了其他变量的值</strong>。这很容易引发错误，而且难以发现。</p><p>数组也可以在声明时，使用大括号，同时对每一个成员赋值。<br>使用<strong>大括号赋值</strong>时，必须在<strong>数组声明时赋值</strong>，也不能<strong>使用大括号对数组重新赋值</strong><br>同时大括号内的值必须<strong>小于等于</strong>数组中成员数量，<strong>未被赋值的成员将被设为0</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">22</span>, <span class="hljs-number">37</span>, <span class="hljs-number">3490</span>, <span class="hljs-number">18</span>, <span class="hljs-number">95</span>&#125;;<br></code></pre></td></tr></table></figure><p>数组初始化时，可以指定为哪些位置的成员赋值，同时不需要按照成员顺序进行排列，下面大括号内的值可以交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">15</span>] = &#123;[<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>, [<span class="hljs-number">9</span>] = <span class="hljs-number">7</span>, [<span class="hljs-number">14</span>] = <span class="hljs-number">48</span>&#125;;<br></code></pre></td></tr></table></figure><p>允许<strong>省略&#x3D;&#x3D;方括号&#x3D;&#x3D;里面的数组成员数量</strong>，这时将根据大括号里面的值的数量，<strong>自动确定数组的长度</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">22</span>, <span class="hljs-number">37</span>, <span class="hljs-number">3490</span>&#125;; <span class="hljs-comment">//此时数组长度被自动设为 3</span><br></code></pre></td></tr></table></figure><p>省略成员数量时，如果同时采用指定位置的赋值，那么<strong>数组长度</strong>将是<strong>最大的指定位置再加1</strong>。由[[#^15b51e|差一行为]]导致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;[<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>, [<span class="hljs-number">9</span>] = <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">//此时数组长度为 10</span><br></code></pre></td></tr></table></figure><h1 id="2-数组长度"><a href="#2-数组长度" class="headerlink" title="2. 数组长度"></a>2. 数组长度</h1><blockquote><p><code>sizeof</code> 运算符会返回整个数组的<strong>字节长度</strong>。即返回某个值占用的字节数量 [[五、数据类型#8. sizeof 运算符|sizeof 运算符]]<br>作用于单个数组成员时将会返回该成员的字节长度<br><code>sizeof</code> 返回值的数据类型是 [[杂项&#x2F;sizeof 运算符的返回值#^65977a|size_t]]，在 <code>printf()</code> 里面的占位符，要用 <code>%zd</code> 或 <code>%zu</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">22</span>, <span class="hljs-number">37</span>, <span class="hljs-number">3490</span>&#125;;<br><span class="hljs-type">int</span> arrLen = <span class="hljs-keyword">sizeof</span>(a); <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>上面示例中，<code>sizeof</code> 返回数组 <code>a</code> 的字节长度是 <code>12</code></p><p>数组成员均为同意类型，因此将 $数组整体的字节长度 \div 某个数组成员的字节长度 &#x3D; 数组成员的数量$ </p><h1 id="3-多维数组"><a href="#3-多维数组" class="headerlink" title="3. 多维数组"></a>3. 多维数组</h1><blockquote><p>C 语言允许声明多个维度的数组，有<strong>多少个维度</strong>，就用<strong>多少个方括号</strong>，比如二维数组就使用两个方括号。<br>多维数组可以理解成，<strong>上层维度</strong>的<strong>每个成员本身就是一个数组</strong>。比如上例中，第一个维度的每个成员本身就是一个有10个成员的数组，因此整个二维数组共有100个成员（10 x 10 &#x3D; 100）。<br>可将多维数组看作是一个<strong>多维坐标系</strong>，且<strong>上一级维度</strong>中的<strong>每个成员</strong>所<strong>代表的数组</strong>就是一<strong>整个下一级维度</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> board[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">13</span>;<br>board[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = <span class="hljs-number">13</span>;<br></code></pre></td></tr></table></figure><p>多维数组也可以使用大括号，一次性对所有成员赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">5</span>] = &#123;<br>  &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>  &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种赋值写法相当于<strong>将第一维的每个成员写成一个数组</strong>。这种写法不用为每个成员都赋值，缺少的成员会自动设置为 <code>0</code>。</p><p>多维数组也可以指定位置，进行初始化赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><p>指定了 <code>[0][0]</code> 和 <code>[1][1]</code> 位置的值，其他位置就自动设为 <code>0</code>。</p><p>不管数组有多少维度，在内存里面都是<strong>线性存储</strong>，<code>a[0][0]</code> 的后面是 <code>a[0][1]</code>，<code>a[0][1]</code> 的后面是 <code>a[1][0]</code>，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句与上面的赋值语句是完全等同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-变长数组"><a href="#4-变长数组" class="headerlink" title="4. 变长数组"></a>4. 变长数组</h1><blockquote><p>数组声明的时候，数组<strong>长度除了使用常量，&#x3D;&#x3D;也可以使用变量&#x3D;&#x3D;<strong>。这叫做变长数组（variable-length array，简称 VLA）。<br>也可</strong>用于高维数组</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n = x + y;<br><span class="hljs-type">int</span> arr[n];<br></code></pre></td></tr></table></figure><p>上面示例中，数组 <code>arr</code> 就是变长数组，数组长度取决于变量 <code>n</code> 的值</p><h1 id="5-数组的地址"><a href="#5-数组的地址" class="headerlink" title="5. 数组的地址"></a>5. 数组的地址</h1><p>数组是一连串连续储存的同类型值，只要获得<strong>起始地址（首个成员的内存地址）</strong>，就能推算出其他成员的地址。请看下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p;<br><br>p = &amp;a[<span class="hljs-number">0</span>];<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);  <span class="hljs-comment">// Prints &quot;11&quot;</span><br></code></pre></td></tr></table></figure><p>上面示例中，<code>&amp;a[0]</code> 就是数组 <code>a</code> 的首个成员 <code>11</code> 的内存地址，也是整个数组的起始地址。反过来，从这个地址（<code>*p</code>），可以获得首个成员的值 <code>11</code>。</p><p>C 语言提供了便利写法<br>c，也就是说，<strong>数组名</strong>就是指向第一个成员（<code>array[0]</code>）的<strong>指针</strong>。 ^c5e6af</p><p>如果把<strong>数组名</strong>传入一个<strong>函数</strong>，就<strong>等同于传入一个指针变量</strong>。在函数内部，就可以通过这个指针变量获得整个数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-comment">// 写法二</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span>;<br></code></pre></td></tr></table></figure><p>上面示例中，传入<strong>一个整数数组</strong>，与传入<strong>一个整数指针</strong>是同一回事，数组符号 <code>[]</code> 与指针符号 <code>*</code> 是可以互换的。</p><p><code>*</code> 和 <code>&amp;</code> 运算符也可以用于多维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 取出 a[0][0] 的值</span><br>*(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 等同于</span><br>**a<br></code></pre></td></tr></table></figure><p>上面示例中，由于 <code>a[0]</code><strong>本身是一个指针</strong>，指向第二维数组的第一个成员 <code>a[0][0]</code>。<br>（[[八、数组#^c5e6af|如同]] <code>a</code> 指向一维数组 <code>a[]</code> 中的第一个成员 <code>a[0]</code>）</p><p>所以，<code>*(a[0])</code> 取出的是 <code>a[0][0]</code> 的值。至于 <code>**a</code>，就是对 <code>a</code> 进行两次 <code>*</code> 运算，第一次取出的是 <code>a[0]</code>，第二次取出的是 <code>a[0][0]</code>。同理，二维数组的 <code>&amp;a[0][0]</code> 等同于 <code>*a</code>。</p><p>&#x3D;&#x3D;数组名指向的地址是不能更改的&#x3D;&#x3D;。声明数组时，编译器自<strong>动为数组分配了内存地址</strong>，这个<strong>地址与数组名是绑定的</strong>，不可更改<br>这也导致&#x3D;&#x3D;<strong>不能</strong>&#x3D;&#x3D;将<strong>一个数组名赋值给另外一个数组名</strong>。</p><h1 id="6-数组指针的加减法"><a href="#6-数组指针的加减法" class="headerlink" title="6. 数组指针的加减法"></a>6. 数组指针的加减法</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><blockquote><p>数组名可以进行加法和减法运算，<strong>等同于在数组成员之间前后移动</strong>，即从一个成员的内存地址移动到另一个成员的内存地址。<br>比如，<code>a + 1</code> 返回下一个成员的地址，<code>a - 1</code> 返回上一个成员的地址。</p></blockquote><p>[[#^c5e6af|数组名等同于起始地址]]，因此通过数组指针的加减法可以访问数组内的所有成员 ^32dd0a</p><p>由于数组名与指针是等价的，所以下面的等式总是成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a[b] == *(a + b)<br></code></pre></td></tr></table></figure><p>上面代码给出了数组成员的两种访问方式，一种是<strong>使用方括号 <code>a[b]</code><strong>，另一种是</strong>使用指针 <code>*(a + b)</code>。</strong></p><p>如果指针变量 <code>p</code> 指向数组的一个成员，那么**<code>p++</code> 就相当于指向下一个成员**，这种方法常用来遍历数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">999</span>&#125;;<br><span class="hljs-type">int</span>* p = a;<br></code></pre></td></tr></table></figure><p><strong>数组名指向的地址是不能变的</strong>，所以上例中，<strong>不能直接对 <code>a</code> 进行自增</strong>，即 <code>a++</code> 的写法是错的，必须将 <code>a</code> 的地址赋值给指针变量 <code>p</code>，然后对 <code>p</code> 进行自增。</p><p>遍历数组<strong>一般都是通过数组长度的比较</strong>来实现，但也可以通过&#x3D;&#x3D;<strong>数组起始地址和结束地址的比较</strong>&#x3D;&#x3D;来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* start, <span class="hljs-type">int</span>* end)</span> &#123;<br>  <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>    total += *start;<br>    start++;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">39</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, sum(arr, arr + <span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><p>上面示例中，<code>arr</code> 是数组的起始地址，<code>arr + 5</code> 是结束地址。只要起始地址小于结束地址，就表示还没有到达数组尾部。</p><p>反过来，通过<strong>数组的减法</strong>，可以知道<strong>两个地址之间有多少个数组成员</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">39</span>, <span class="hljs-number">88</span>&#125;;<br><span class="hljs-type">int</span>* p = arr;<br><br><span class="hljs-keyword">while</span> (*p != <span class="hljs-number">88</span>)<br>  p++; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">此处 p 是一个地址，自加 1 参考指针与整数的加减法，实质上是将地址向后，最终 p 将成为数组中的最后一个成员的地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, p - arr);  <br></code></pre></td></tr></table></figure><p>上面示例中，将<strong>某个数组成员的地址</strong>，<strong>减去</strong>数组<strong>起始地址</strong>，就可以知道，当前成员与起始地址之间有多少个成员。<br>[[六、指针#（1）指针与整数值的加减运算|指针与整数值的加减]]</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><blockquote><p>对于多维数组，数组指针的加减法<strong>对于不同维度</strong>，含义是<strong>不一样</strong>的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 指针指向 arr[1]</span><br>arr + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 指针指向 arr[0][1]</span><br>arr[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>因为多维数组中的<strong>每个维度的每个成员</strong>都包含下一维度的<strong>所有成员</strong>，与一维数组中[[#^32dd0a|数组名等同于起始地址]]相同，<code>arr[0]</code> 可视作是第二维度数组的起始地址，<br>因此 <code> arr[0] + 1</code> 的指针指向 ar[0][1]</p><h1 id="7-数组的复制"><a href="#7-数组的复制" class="headerlink" title="7. 数组的复制"></a>7. 数组的复制</h1><blockquote><p>由于<strong>数组名是指针</strong>，所以复制数组<strong>不能简单地复制</strong>数组名。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* a;<br><span class="hljs-type">int</span> b[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>a = b;<br></code></pre></td></tr></table></figure><p>此种方法实质上是<strong>令 a 和 b 指向了同一个数组</strong>，因为 b 实际上是一个地址，[[六、指针#1. 简介|指针]]</p><p>复制数组最简单的方法，还是使用<strong>循环</strong>，将数组元素<strong>逐个进行复制</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>  a[i] = b[i];<br></code></pre></td></tr></table></figure><p>此方法额外创建了一个数组，并挨个从 b 中复制成员</p><p>另一种方法是使用 [[头文件&#x2F;string.h#<code>memcpy()</code> 函数|memcpy()]] 函数（定义在头文件 <code>string.h</code>），直接把数组所在的那一段内存，再复制一份。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memcpy</span>(a, b, <span class="hljs-keyword">sizeof</span>(b));<br></code></pre></td></tr></table></figure><h1 id="8-作为函数的参数"><a href="#8-作为函数的参数" class="headerlink" title="8. 作为函数的参数"></a>8. 作为函数的参数</h1><h1 id="8-1-声明参数数组"><a href="#8-1-声明参数数组" class="headerlink" title="8.1 声明参数数组"></a>8.1 声明参数数组</h1><blockquote><p>数组作为函数的参数，一般会同时传入<strong>数组名</strong>和<strong>数组长度</strong>。</p></blockquote><h3 id="一维函数"><a href="#一维函数" class="headerlink" title="一维函数"></a>一维函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> sum = sum_array(a, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>上面示例中，函数 <code>sum_array()</code> 的<strong>第一个参数是数组本身</strong>，也就是数组名，<strong>第二个参数是数组长度</strong>。</p><p>数组名就是一个<strong>指针</strong>，指向<strong>数组开始</strong>的地址，因此我们需要提供数组长度以告诉函数<strong>数组结束的</strong>地址</p><h3 id="多维函数"><a href="#多维函数" class="headerlink" title="多维函数"></a>多维函数</h3><p>如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，<strong>其他维的长度</strong>&#x3D;&#x3D;需要&#x3D;&#x3D;写入函数的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = &#123;<br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>  &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;<br>&#125;;<br><span class="hljs-type">int</span> sum = sum_array(a, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>将数组作为函数的参数时，需要让函数知道<strong>数组的起止位置</strong><br>而多维数组（如二维数组）的第一维度的每一个成员都是一个数组，编译器仅靠函数参数中提供的第一维度的数组数量<strong>无法确定</strong>数组的结束地址，因此我们需要提供第一维度中<strong>每个成员所代表的数组的字节长度</strong>，即第二维度的长度</p><h1 id="8-2-变长数组作为参数"><a href="#8-2-变长数组作为参数" class="headerlink" title="8.2 变长数组作为参数"></a>8.2 变长数组作为参数</h1><blockquote><p>变长数组作为函数参数时，写法略有不同。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a[n])</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> sum = sum_array(<span class="hljs-number">4</span>, a);<br></code></pre></td></tr></table></figure><p>上面示例中，数组 <code>a[n]</code> 是一个变长数组，它的<strong>长度取决于变量 <code>n</code> 的值</strong>，<strong>只有运行时才能知道</strong>。所以，&#x3D;&#x3D;<strong>变量 <code>n</code> 作为参数时，顺序一定要在变长数组前面</strong>&#x3D;&#x3D;，这样运行时才能确定数组 <code>a[n]</code> 的长度，否则就会报错。</p><p>因为&#x3D;&#x3D;<strong>函数原型可以省略参数名</strong>&#x3D;&#x3D;，所以变长数组的原型中，可以使用 <code>*</code> 代替变量名，也可以省略变量名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span> [*])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span> [])</span>;<br></code></pre></td></tr></table></figure><p>变长数组作为函数参数有一个好处，就是<strong>多维数组</strong>的参数声明，可以<strong>把后面的维度省掉了</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 原来的写法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n)</span>;<br><br><span class="hljs-comment">// 变长数组的写法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum_array</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> a[n][m])</span>;<br><span class="hljs-comment">//此处第二维度的长度作为变量传入函数</span><br></code></pre></td></tr></table></figure><h1 id="8-3-数组字面量作为参数"><a href="#8-3-数组字面量作为参数" class="headerlink" title="8.3 数组字面量作为参数"></a>8.3 数组字面量作为参数</h1><blockquote><p>C 语言允许<strong>将数组字面量作为参数</strong>，传入函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 数组字面量作为参数</span><br><span class="hljs-type">int</span> sum = sum_array((<span class="hljs-type">int</span> [])&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>省掉了数组变量的声明，<strong>直接将数组字面量传入函数</strong>。<code>&#123;2, 3, 4, 5&#125;</code> 是数组值的字面量，<code>(int [])</code> 类似于强制的类型转换，告诉编译器怎么理解这组值。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10.内存管理</title>
    <link href="/2024/02/24/%E5%8D%81%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/02/24/%E5%8D%81%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>系统管理<ul><li>栈</li><li>局部变量，函数运行时进入内存，运行结束卸载</li></ul></li><li>用户手动管理<ul><li>堆</li><li>全局变量</li><li>内存泄漏</li></ul></li></ul><blockquote><p>系统管理的内存，主要是<strong>函数内部的变量（局部变量）</strong>。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。<br>用户手动管理的内存，主要是<strong>程序运行的整个过程中都存在的变量（全局变量）</strong>，这些变量需要用户手动从内存释放。如果使用后忘记释放，它就<strong>一直占用内存，直到程序退出</strong>，这种情况称为“<strong>内存泄漏</strong>”（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。</p></blockquote><h1 id="2-void-指针"><a href="#2-void-指针" class="headerlink" title="2. void 指针"></a>2. void 指针</h1><blockquote><p><strong>每一块内存</strong>都有<strong>地址</strong>，通过## void 指针可以获取指定地址的内存块。指针变量必须有<strong>类型</strong>，否则编译器无法知道，如何解读内存块保存的二进制数据。</p><p>请求内存时却<strong>不确定</strong>内存的数据类型，于是我们使用<strong>不定类型的指针“void 指针”</strong>。它<strong>只有内存块的地址信息</strong>，没有类型信息，等到<strong>使用该块内存的时候</strong>，<strong>再向编译器补充说明</strong>，里面的数据类型是什么。</p></blockquote><p>void 指针<strong>等同于无类型指针</strong>，可以<strong>指向任意类型的数据</strong>，但是<strong>不能解读数据</strong></p><ul><li><strong>指向任意类型的数据</strong><ul><li>任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。<strong>（相互转换）</strong></li></ul></li><li><strong>不能解读数据</strong><ul><li>但由于无法确定指向的数据的类型，所以<strong>无法使用 <code>*</code> 运算符</strong>取出 void 指针指向的值</li></ul></li></ul><h1 id="3-malloc"><a href="#3-malloc" class="headerlink" title="3. malloc()"></a>3. malloc()</h1><blockquote><p><code>malloc()</code> 函数用于<strong>分配内存</strong>，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件 <code>stdlib.h</code>。<br>接受一个&#x3D;&#x3D;<strong>非负整数作为参数</strong>&#x3D;&#x3D;，表示所要分配的<strong>内存字节数</strong>，&#x3D;&#x3D;返回一个 <strong>void 指针&#x3D;&#x3D;，指向分配好的内存块</strong>。<br>可以使用 <code>malloc()</code> 为任意类型的数据分配内存，常见的做法是先使用** <code>sizeof()</code> 函数** ，算出<strong>某种数据类型所需的字节长度</strong>，然后再将这个长度传给 <code>malloc()</code>。[[五、数据类型#8. sizeof 运算符|sizeof]]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//此时已为 p 分配了一个确定的内存地址</span><br><br>*p = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p); <span class="hljs-comment">// 12</span><br><span class="hljs-comment">/*实质上，C语言会自动为int类型提供内存*/</span><br></code></pre></td></tr></table></figure><p>有时候为了增加代码的可读性，可以对<code>malloc()</code>返回的指针进行一次<strong>强制类型转换</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p><code>sizeof()</code> 的参数<strong>可以是变量</strong>，所以上面的例子也可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*p));<br></code></pre></td></tr></table></figure><p><code>malloc()</code> 分配内存<strong>有可能分配失败</strong>，这时<strong>返回常量 <code>NULL</code><strong>。</strong><code>Null</code> 的值为0</strong>，是一个<strong>无法读写的内存地址</strong>，可以理解成一个<strong>不指向任何地方的指针</strong>。</p><p><code>malloc()</code> 最<strong>常用</strong>的场合，就是<strong>为数组和自定义数据结构分配内存</strong>。<br><code>malloc()</code> 用来创建数组，有一个好处，就是它<strong>可以创建动态数组</strong>，即根据成员<strong>数量的不同</strong>，而<strong>创建长度不同</strong>的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p>上面示例中，<code>malloc()</code> 可以根据<strong>变量 <code>n</code> 的不同</strong>，动态为数组<strong>分配不同的大小</strong>。</p><p><code>malloc()</code><strong>不会对所分配的内存进行初始化</strong>，里面<strong>还保存着原来的值</strong>。如果没有初始化，就使用这段内存，可能从里面读到以前的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">//为字符串变量赋值</span><br></code></pre></td></tr></table></figure><h1 id="4-free"><a href="#4-free" class="headerlink" title="4. free()"></a>4. free()</h1><blockquote><p><code>free()</code> 用于<strong>释放 <code>malloc()</code> 函数分配的内存</strong>，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件 <code>stdlib.h</code> 里面。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* block)</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>free()</code> 的<strong>参数</strong>是 <code>malloc()</code><strong>返回的内存地址</strong><br>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//p是malloc为其分配的地址</span><br><br>*p = <span class="hljs-number">12</span>;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p>分配的内存块<strong>一旦释放</strong>，就<strong>不应该再次操作</strong>已经释放的地址，也<strong>不应该</strong>再次使用 <code>free()</code> 对该地址<strong>释放第二次</strong>。</p><p>函数内部未释放内存，而函数运行结束后，指向<strong>已分配地址的指针消失</strong>，则每次调用该函数都会留下<strong>无法访问的内存块</strong>，造成内存浪费</p><h1 id="5-calloc"><a href="#5-calloc" class="headerlink" title="5. calloc()"></a>5. calloc()</h1><blockquote><p><code>calloc()</code>函数的作用与<code>malloc()</code>相似，也是分配内存块。该函数的原型定义在头文件<code>stdlib.h</code>。</p></blockquote><ul><li><code>calloc()</code> 接受<strong>两个参数</strong>，第一个参数是<strong>某种数据类型的值的数量</strong>，第二个是该<strong>数据类型的单位字节长度</strong>。（malloc 是直接放入总字节，而 calloc 参数的乘积是总字节）</li><li><code>calloc()</code>会**将所分配的内存全部初始化为<code>0</code>**。<code>malloc()</code>不会对内存进行初始化，如果想要初始化为<code>0</code>，还要额外调用<code>memset()</code>函数。</li></ul><table><thead><tr><th></th><th align="center">接受的参数</th><th align="center">是否会将分配的内存初始化</th><th align="center">返回值</th></tr></thead><tbody><tr><td>malloc()</td><td align="center">一个</td><td align="center">否，直接调用可能会返回内存中已有的值</td><td align="center">void 指针。失败时，返回 NULL。</td></tr><tr><td>calloc()</td><td align="center">两个</td><td align="center">是</td><td align="center">void 指针。失败时，返回 NULL。</td></tr></tbody></table><h1 id="6-realloc"><a href="#6-realloc" class="headerlink" title="6. realloc()"></a>6. realloc()</h1><blockquote><p><code>realloc()</code> 函数用于<strong>修改已经分配的内存块的大小</strong>，可以<strong>放大</strong>也可以<strong>缩小</strong>，<strong>返回</strong>一个<strong>指向新的内存块的指针</strong>。如果分配不成功，返回 NULL。该函数的原型定义在头文件 <code>stdlib.h</code>。</p></blockquote><p>它接受两个参数。</p><ul><li><code>block</code>：<strong>已经分配好</strong>的内存块指针（由<code>malloc()</code>或<code>calloc()</code>或<code>realloc()</code>产生）。</li><li><code>size</code>：该内存块的<strong>新大小</strong>，单位为字节。</li></ul><p><strong>可能</strong>返回一个<strong>全新</strong>的地址（数据也会自动复制过去），也可能返回跟<strong>原来一样</strong>的地址<br>realloc 优先在原内存块修改，通常返回后者</p><p>如果新内存块<strong>小于</strong>原来的大小，则<strong>丢弃</strong>超出的部分；如果<strong>大于</strong>原来的大小，则<strong>不对新增的部分进行初始化</strong>（程序员可以自动调用 <code>memset()</code>）。即原始内存块中数据所占据的内存以外的部分<strong>数据是不确定的</strong></p><p><code>realloc()</code> 的<strong>第一个参数可以是 NULL</strong>，这时就<strong>相当于新建一个指针</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = <span class="hljs-built_in">realloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">3490</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">char</span>* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">3490</span>);<br></code></pre></td></tr></table></figure><p>将第二个参数设为 0，即让新的内存大小为0，相当于<strong>释放掉内存块</strong></p><p><strong>有分配失败的可能</strong>，所以调用 <code>realloc()</code> 以后，最好<strong>检查一下它的返回值</strong>是否为 NULL。分配失败时，<strong>原有内存块中的数据不会发生改变</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span>* new_p = <span class="hljs-built_in">realloc</span>(p, <span class="hljs-keyword">sizeof</span>(*p * <span class="hljs-number">40</span>));<br><br><span class="hljs-keyword">if</span> (new_p == <span class="hljs-literal">NULL</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error reallocing\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>realloc()</code> 不会对内存块进行初始化。</p><h1 id="7-restrict-说明符"><a href="#7-restrict-说明符" class="headerlink" title="7. restrict 说明符"></a>7. restrict 说明符</h1><blockquote><p>声明指针变量时，可以使用 <code>restrict</code> 说明符，告诉编译器，<strong>该块内存区域只有当前指针一种访问方式</strong>，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。(即不可将该地址赋予其他指针)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-keyword">restrict</span> p;<br>p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><p>上面示例中，声明指针变量 <code>p</code> 时，加入了 <code>restrict</code> 说明符，使得**<code>p</code> 变成了受限指针** 。后面，当 <strong><code>p</code> 指向 <code>malloc()</code> 函数返回的一块内存区域</strong>，就意味着，<strong>该区域只有通过 <code>p</code> 来访问</strong>，不存在其他访问方式。</p><h1 id="8-memcpy"><a href="#8-memcpy" class="headerlink" title="8. memcpy()"></a>8. memcpy()</h1><blockquote><p><code>memcpy()</code> 用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件 <code>string.h</code>。  </p></blockquote><p>该函数内涵三个参数</p><ol><li>指向<strong>内存目标区域</strong>的指针，即<strong>复制后</strong>数据储存的位置</li><li>指向<strong>源内存区域</strong>的指针，即<strong>要被复制</strong>的数据。</li><li>要被复制的<strong>字节数</strong>。</li></ol><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memcpy</span>(a, b, <span class="hljs-keyword">sizeof</span>(b));<br></code></pre></td></tr></table></figure><p>将要将 b 指向的内存地址中的数据复制一份到 a 指向的内存地址，总共复制 <code>sizeof (b)</code> 字节的数据</p><h1 id="9-memmove"><a href="#9-memmove" class="headerlink" title="9. memmove()"></a>9. memmove()</h1><blockquote><p> <code>memmove()</code> 函数用于<strong>将一段内存数据复制到另一段内存</strong>。它跟 <code>memcpy()</code> 的主要区别是，它<strong>允许目标区域与源区域有重叠</strong>。如果<strong>发生重叠，&#x3D;&#x3D;源区域&#x3D;&#x3D;的内容会被更改</strong>；如果没有重叠，它与 <code>memcpy()</code> 行为相同。<br> 头文件 <code>string.h</code>。\</p></blockquote><h1 id="10-memcmp"><a href="#10-memcmp" class="headerlink" title="10. memcmp()"></a>10. memcmp()</h1><blockquote><p> <code>memcmp()</code> 函数用来<strong>比较两个内存区域</strong>。它的原型定义在 <code>string.h</code>。<br> 接受<strong>三个参数</strong>，前两个参数是用来比较的指针，第三个参数指定比较的字节数。<br> 返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回<code>0</code>；如果<code>s1</code>大于<code>s2</code>，返回大于0的整数；如果<code>s1</code>小于<code>s2</code>，返回小于0的整数。<br> [[九、字符串#8.strcmp()|strcmp()]]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span>* s2 = <span class="hljs-string">&quot;acd&quot;</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">memcmp</span>(s1, s2, <span class="hljs-number">3</span>); <span class="hljs-comment">// 小于 0</span><br></code></pre></td></tr></table></figure><p>上面示例比较<code>s1</code>和<code>s2</code>的前三个字节，由于<code>s1</code>小于<code>s2</code>，所以<code>r</code>是一个小于0的整数，一般为-1。</p><p><code>memcmp()</code> 可以比较内部带有字符串终止符 <code>\0</code> 的内存区域。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.流程控制</title>
    <link href="/2024/02/24/%E5%9B%9B%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/02/24/%E5%9B%9B%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>C 语言的程序是顺序执行，即先执行前面的语句，再执行后面的语句。开发者如果想要控制程序执行的流程，就必须使用流程控制的语法结构，主要是条件执行和循环执行。</p></blockquote><h1 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h1><blockquote><p><code>if</code> 语句用于条件判断，满足条件时，就执行指定的语句。<br><code>if (判断条件) 语句体</code></p></blockquote><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (expression) statement<br></code></pre></td></tr></table></figure><p>如果表达式 <code>expression</code> 为真，则执行 statement<br>判断条件<strong>外部必须有圆括号</strong></p><p>语句体部分 <code>statement</code> 可以是一个语句，也可以是放在大括号里面的复合语句<br>对于只有一个语句的语句体，语句部分通常另起一行，<br>如果有多条语句，就需要把它们放在大括号里面，组成一个复合语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (line_num == MAX_LINES) &#123;<br>line_num = <span class="hljs-number">0</span>;<br>page_num++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>if</code> 语句可以带有 <code>else</code> 分支，指定条件不成立时（表达式 <code>expression</code> 的值为 <code>0</code>），所要执行的代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (i &gt; j)<br>max = i;<br><span class="hljs-keyword">else</span><br>max = j;<br></code></pre></td></tr></table></figure><blockquote><p><code>else</code> 可以与另一个 <code>if</code> 语句连用，构成多重判断。<br>如果有多个 <code>if</code> 和 <code>else</code>，可以记住这样一条规则，<code>else</code> 总是跟最接近的 <code>if</code> 匹配。<br>为了提供代码的可读性，建议使用大括号，明确 <code>else</code> 匹配哪一个 <code>if</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">6</span>) &#123;<br>  <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">12</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number is more than 6, less than 12.\n&quot;</span>);<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It is wrong number.\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 如果 `number` 大于 `6` 且小于 `12`，则输出 &quot;The number is more than 6, less than 12.&quot;。</span><br><span class="hljs-comment">2. 如果 `number` 不满足以上条件，则输出 &quot;It is wrong number.&quot;。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="2-三元运算符"><a href="#2-三元运算符" class="headerlink" title="2. 三元运算符 ?:"></a>2. 三元运算符 ?:</h1><blockquote><p>C 语言有一个三元表达式 <code>?:</code>，可以用作 <code>if...else</code> 的简写形式。</p><blockquote><p><code>&lt;expression1&gt; ? &lt;expression2&gt; : &lt;expression3&gt;</code><br>这个操作符的含义是，表达式 <code>expression1</code> 如果为 <code>true</code>（非0值），就执行 <code>expression2</code>，否则执行 <code>expression3</code>。</p></blockquote></blockquote><h1 id="3-switch-语句"><a href="#3-switch-语句" class="headerlink" title="3. switch 语句"></a>3. switch 语句</h1><blockquote><p>switch 语句是一种特殊形式的 if… else 结构，用于判断条件有多个结果的情况。它把多重的 <code>else if</code> 改成更易用、可读性更好的形式。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (expression) &#123;<br>  <span class="hljs-keyword">case</span> value1: statement<br>  <span class="hljs-keyword">case</span> value2: statement<br>  <span class="hljs-keyword">default</span>: statement<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码中，根据表达式 <code>expression</code> 不同的值，执行相应的 <code>case</code> 分支。如果找不到对应的值，就执行 <code>default</code> 分支。</p></blockquote><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (grade) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;False&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;True&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Illegal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据变量 <code>grade</code> 不同的值，会执行不同的 <code>case</code> 分支。如果等于 <code>0</code>，执行 <code>case 0</code> 的部分；如果等于 <code>1</code>，执行 <code>case 1</code> 的部分；否则，执行 <code>default</code> 的部分。<code>default</code> 表示处理以上所有 <code>case</code> 都不匹配的情况。</p><blockquote><p>每个 <code>case</code> 语句体的结尾，都应该有一个 <code>break</code> 语句，作用是跳出整个 <code>switch</code> 结构，不再往下执行。如果缺少 <code>break</code>，就会导致继续执行下一个 <code>case</code> 或 <code>default</code> 分支。<br><code>case</code> 后面的语句体，不用放在大括号里面，这也是为什么需要 <code>break</code> 的原因。<br><code>default</code> 分支用来处理前面的 case 都不匹配的情况，最好放在所有 case 的后面，这样就不用写 <code>break</code> 语句。这个分支是<strong>可选</strong>的，如果没有该分支，<strong>遇到所有的 case 都不匹配的情况，就会直接跳出整个 switch 代码块</strong>。</p></blockquote><h1 id="4-while-语句"><a href="#4-while-语句" class="headerlink" title="4. while 语句"></a>4. while 语句</h1><p>^0150fb</p><blockquote><p><code>while</code> 语句用于循环结构，满足条件时，不断执行循环体。<br>如果循环体有多个语句，就需要使用大括号将这些语句组合在一起。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (expression)<br>statement<br><br><span class="hljs-title function_">while</span> <span class="hljs-params">(expression)</span> &#123;<br>statement;<br>statement;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>expression</code> 为非零值（表示真），就会执行 <code>statement</code> 语句，然后再次判断 <code>expression</code> 是否为零；如果 <code>expression</code> 为零（表示伪）就跳出循环，不再执行循环体</p><h1 id="6-do…while-结构"><a href="#6-do…while-结构" class="headerlink" title="6. do…while 结构"></a>6. do…while 结构</h1><blockquote><p><code>do...while</code> 结构是 <code>while</code> 的变体，它会先执行一次循环体，然后再判断是否满足条件。如果满足的话，就继续执行循环体，否则跳出循环。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> statement<br><span class="hljs-title function_">while</span> <span class="hljs-params">(expression)</span>;<br></code></pre></td></tr></table></figure><p>不管条件 <code>expression</code> 是否成立，循环体 <code>statement</code><strong>至少会执行一次</strong>。每次 <code>statement</code> 执行完毕，就会判断一次 <code>expression</code>，决定是否结束循环。<br>与 [[#^0150fb|while 语句]]相比，似乎是进行了一次倒置，因此 do-while 必定会执行一次 do </p><h1 id="6-for-语句"><a href="#6-for-语句" class="headerlink" title="6.for 语句"></a>6.for 语句</h1><blockquote><p><code>for</code> 语句是最常用的循环结构，通常用于精确控制循环次数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (initialization; continuation; action)<br>  statement;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>for</code>语句的条件部分（即圆括号里面的部分）有三个表达式。</p><ul><li><code>initialization</code>：初始化表达式，用于初始化循环变量，<strong>只执行一次</strong>。<ul><li>影响循环是否进行的<strong>核心</strong></li></ul></li><li><code>continuation</code>：判断表达式，&#x3D;&#x3D;<strong>只要为 <code>true</code>，就会不断执行</strong>&#x3D;&#x3D;循环体。<ul><li>判断循环是否进行的一个<strong>限定条件</strong></li></ul></li><li><code>action</code>：循环变量处理表达式，&#x3D;&#x3D;<strong>每轮循环结束后执行</strong>&#x3D;&#x3D;，使得循环变量发生变化。<ul><li>修改变量，与循环变量共同&#x3D;&#x3D;<strong>决定循环执行的次数</strong>&#x3D;&#x3D;<br>  循环体部分的 <code>statement</code> 可以是一条语句，也可以是放在大括号里面的复合语句。</li></ul></li></ul><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i is %d\n&quot;</span>, i);<br></code></pre></td></tr></table></figure><p>循环变量 <code>i</code> 在 <code>for</code> 的第一个表达式里面声明，该变量只用于本次循环。离开循环体之后，就会失效<br>当 <code>i &gt; 0</code> 为 false 时则循环停止<br>每次循环结束后 i 自减 1 </p><blockquote><p>条件部分的三个表达式，每一个都可以有多个语句，语句与语句之间使用逗号分隔。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">999</span>; i &lt; <span class="hljs-number">10</span>; i++, j--) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d\n&quot;</span>, i, j);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>for</code> 的三个表达式都不是必需的，甚至可以全部省略，这会形成无限循环</p></blockquote><h1 id="7-break-语句"><a href="#7-break-语句" class="headerlink" title="7. break 语句"></a>7. break 语句</h1><blockquote><p><code>break</code> 语句有两种用法。一种是与 <code>switch</code> 语句配套使用，用来中断某个分支的执行，这种用法前面已经介绍过了。另一种用法是在循环体内部跳出循环，不再进行后面的循环了。<br>注意，<code>break</code> 命令<strong>只能跳出循环体和 <code>switch</code> 结构</strong>，不能跳出 <code>if</code> 结构。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 无效</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，<code>break</code> 语句是无效的，因为它不能跳出外层的 <code>if</code> 结构。</p><h1 id="8-continue-语句"><a href="#8-continue-语句" class="headerlink" title="8.continue 语句"></a>8.continue 语句</h1><blockquote><p><code>continue</code> 语句用于在循环体内部终止本轮循环，进入下一轮循环。只要遇到 <code>continue</code> 语句，循环体内部后面的语句就不执行了，回到循环体的头部，开始执行下一轮循环。</p></blockquote><p>同 [[..&#x2F;python&#x2F;一、基础知识&#x2F;7. 用户输入和 while 循环#使用 continue 跳过循环|python]]</p><h1 id="9-goto-语句"><a href="#9-goto-语句" class="headerlink" title="9.goto 语句"></a>9.goto 语句</h1><blockquote><p>goto 语句用于跳到指定的标签名。这会破坏结构化编程，&#x3D;&#x3D;建议不要轻易使用&#x3D;&#x3D;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> ch;<br><br>top: ch = getchar();<br><br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;q&#x27;</span>)<br><span class="hljs-keyword">goto</span> top;<br></code></pre></td></tr></table></figure><p>上面示例中，<code>top</code> 是一个标签名，可以放在正常语句的前面，相当于为这行语句做了一个标记。程序执行到 <code>goto</code> 语句，就会跳转到它指定的标签名。</p><p>goto 的一个主要用法是<strong>跳出多层循环</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(...) &#123;<br>  <span class="hljs-keyword">for</span> (...) &#123;<br>    <span class="hljs-keyword">while</span> (...) &#123;<br>      <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (some_error_condition)<br>          <span class="hljs-keyword">goto</span> bail;    <br>      &#125; <span class="hljs-keyword">while</span>(...);<br>    &#125;<br>  &#125;<br>&#125;<br>    <br>bail:<br><span class="hljs-comment">// ... ...</span><br></code></pre></td></tr></table></figure><p>上面代码有很复杂的嵌套循环，不使用 goto 的话，想要完全跳出所有循环，写起来很麻烦。</p><p>goto 的另一个用途是<strong>提早结束多重判断</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (do_something() == ERR)<br>  <span class="hljs-keyword">goto</span> error;<br><span class="hljs-keyword">if</span> (do_something2() == ERR)<br>  <span class="hljs-keyword">goto</span> error;<br><span class="hljs-keyword">if</span> (do_something3() == ERR)<br>  <span class="hljs-keyword">goto</span> error;<br><span class="hljs-keyword">if</span> (do_something4() == ERR)<br>  <span class="hljs-keyword">goto</span> error;<br></code></pre></td></tr></table></figure><p>上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断（因为直接跳回指定的标签了）。<br>注意，goto &#x3D;&#x3D;只能在同一个函数之中跳转&#x3D;&#x3D;，并不能跳转到其他函数。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.指针</title>
    <link href="/2024/02/24/%E5%85%AD%E3%80%81%E6%8C%87%E9%92%88/"/>
    <url>/2024/02/24/%E5%85%AD%E3%80%81%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p>指针是什么？首先，它是一个<strong>值</strong>，这个值<strong>代表一个[[杂项&#x2F;内存#1. 内存编址|内存地址]]<strong>，因此指针相当于</strong>指向某个内存地址的路标</strong>。</p><p>字符 <code>*</code> 表示指针，通常<strong>跟在类型关键字的后面</strong>，表示指针指向的是什么类型的值。比如，<code>char*</code> 表示一个指向字符的指针，<code>float*</code> 表示一个指向 <code>float</code> 类型的值的指针。<br>星号 <code>*</code> 可以放在变量名与类型关键字（如 int）之间的任何地方</p></blockquote><p>同一行声明多个指针变量 <code>int * foo, * bar;</code></p><p>一个指针指向的可能还是指针，这时就要用两个星号 <code>**</code> 表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>** foo;<br></code></pre></td></tr></table></figure><p>示例表示变量 <code>foo</code> 是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。</p><h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. * 运算符"></a>2. * 运算符</h1><blockquote><p> <code>*</code> 这个符号除了表示指针以外，还可以作为运算符，用来<strong>取出指针变量所指向的内存地址里面的值</strong>。<br> 即将指针变量所指向的地址转化为其对应的值</p></blockquote><p>在 C 语言中，变量的声明存在<strong>作用域</strong>这一概念，使得不同块作用域中定义的变量无法相互干涉，代码块对于块作用域中变量的操作<strong>仅限</strong>于代码块内部，而指针变量使得变量<strong>直接指向</strong>值的<strong>内存地址</strong>，使得代码块内对于某一地址内储存的值进行的操作是<strong>永久的</strong>，也使得对该值得重复使用更加便利且节省空间</p><h1 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. &amp; 运算符"></a>3. &amp; 运算符</h1><blockquote><p><code>&amp;</code> 运算符用来取出一个变量所在的内存地址。<br>即 将某个值转换为其<strong>所在的内存地址</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&#x27;s address is %p\n&quot;</span>, &amp;x);<br></code></pre></td></tr></table></figure><p>上面示例中，<code>x</code> 是一个整数变量，<code>&amp;x</code> 就是 <code>x</code> 的值所在的内存地址。<code>printf()</code> 的** <code>%p</code> 是内存地址的占位符**，可以打印出内存地址。</p><p><code>&amp;</code> 运算符与 <code>*</code> 运算符<strong>互为逆运算</strong>，下面的表达式总是成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">if</span> (i == *(&amp;i)) <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h1 id="4-指针变量的初始化"><a href="#4-指针变量的初始化" class="headerlink" title="4. 指针变量的初始化"></a>4. 指针变量的初始化</h1><blockquote><p>声明指针变量之后，编译器会<strong>为指针变量本身分配一个内存空间</strong>，但是这个内存空间里面的值是<strong>随机</strong>的，也就是说，<strong>指针变量指向的值是随机的</strong>。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p></blockquote><p>因此我们需要让指针变量<strong>指向一个已经&#x3D;&#x3D;分配好的&#x3D;&#x3D;地址</strong>，再对这个地址进行赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p; <span class="hljs-comment">//此时P指向一个值不确定的内存地址</span><br><span class="hljs-type">int</span> i;<span class="hljs-comment">//声明变量 i，为其分配了一个内存空间，此时该空间内未储存任何的值</span><br><br>p = &amp;i; <span class="hljs-comment">//令 p 指向已分配的确定的内存地址</span><br>*p = <span class="hljs-number">13</span>; <span class="hljs-comment">//再为该地址赋值</span><br></code></pre></td></tr></table></figure><h1 id="5-指针的运算"><a href="#5-指针的运算" class="headerlink" title="5. 指针的运算"></a>5. 指针的运算</h1><blockquote><p>指针本质上就是一个<strong>无符号整数</strong>，<strong>代表了内存地址</strong>。它可以进行运算，但是规则并不是整数运算的规则。</p></blockquote><h2 id="（1）指针与整数值的加减运算"><a href="#（1）指针与整数值的加减运算" class="headerlink" title="（1）指针与整数值的加减运算"></a>（1）指针与整数值的加减运算</h2><blockquote><p>指针与整数值的运算，表示指针的移动。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">short</span>* j;<br>j = (<span class="hljs-type">short</span>*)<span class="hljs-number">0x1234</span>;<br>j = j + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0x1236</span><br></code></pre></td></tr></table></figure><p>上面示例中，<code>j</code>是一个指针，指向内存地址<code>0x1234</code>。由于<code>0x1234</code>本身是整数类型（<code>int</code>），跟<code>j</code>的类型（<code>short*</code>）并不兼容，所以强制使用类型投射，将<code>0x1234</code>转成<code>short*</code>。你可能以为<code>j + 1</code>等于<code>0x1235</code>，但正确答案是<code>0x1236</code>。原因是<code>j + 1</code>表示指针向内存地址的高位移动一个单位，而一个单位的<code>short</code>类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，<code>j - 1</code>得到的结果是<code>0x1232</code>。</p><p><strong>指针移动的单位</strong>，与指针指向的<strong>数据类型</strong>有关。<strong>数据类型占据多少个字节</strong>，每单位<strong>就移动多少个字节</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello world</title>
    <link href="/2024/02/19/Hello%20world/"/>
    <url>/2024/02/19/Hello%20world/</url>
    
    <content type="html"><![CDATA[<p><strong>hello world</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
